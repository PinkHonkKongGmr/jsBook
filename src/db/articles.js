import React from 'react';
import { Link } from 'react-router-dom';
import ScrollTo from '../helperComponent/scrollTo';
import Gh from '../hocs/gh';

const Articles = {
    oop: {
        link: '/oop',
        content: (
            <div>
                <h2>Итак, ооп!</h2>
                <p>
                    Начнем с сухих определений. Далеко лазить не будем. Откроем википедию и посмотрим что она скажет нам
                    об ООП
                </p>
                <p>
                    <strong>
                        Объе́ктно-ориенти́рованное программи́рование (ООП) — методология программирования, основанная на
                        представлении программы в виде совокупности объектов, каждый из которых является экземпляром
                        определённого класса, а классы образуют иерархию наследования.
                    </strong>
                </p>
                <p>
                    Спасибо, википедия, из этого мы можем сделать вывод что ООП оперирует обьектами, каждый объект несет
                    ряд свойств и характеристик, по которым их можно объеденить. Тоесть у кажого объекта есть свой
                    класс. Мы можем создавать новые объекты, наделяя их определенным классом. Это значит что новый
                    объект получит(унаследует) всю мощь объекта - прородителя
                </p>
                <p>Хорошо. Но мы, как умные ребята и правильные посоны изучим и другие источники</p>
                <p>
                    <strong>
                        Центральными в ООП являются понятия класса и объекта. Образно говоря, ООП заключается не столько
                        в использовании классов и объектов в программе, сколько в замене принципа программирования "от
                        функции к функции" принципом программирования "от класса к классу". Технология ООП прежде всего
                        накладывает ограничения на способы представления данных в программе. Любая программа отражает в
                        них состояние физических предметов либо абстрактных понятий (назовем их объектами
                        программирования), для работы с которыми она предназначена. В традиционной технологии варианты
                        представления данных могут быть разными. В худшем случае программист может "равномерно
                        размазать" данные о некотором объекте программирования по всей программе. В противоположность
                        этому все данные об объекте программирования и его связях с другими объектами можно объединить в
                        одну структурированную переменную. В первом приближении ее можно назвать объектом. Кроме того, с
                        объектом связывается набор действий, иначе называемых методами. С точки зрения языка
                        программирования это функции, получающие в качестве обязательного параметра указатель на объект.
                        Технология ООП запрещает работать с объектом иначе, чем через методы, то есть внутренняя
                        структура объекта скрыта от внешнего пользователя. Описание множества однотипных объектов
                        называется классом. Объект - структурированная переменная, содержащая всю информацию о некотором
                        физическом предмете или реализуемом в программе понятии. Класс - описание множества таких
                        объектов и выполняемых над ними действий.
                    </strong>
                </p>

                <p>
                    Очень хорошо, так мы приходим к пониманию, что ООП это не столько про классы, сколько про СПОСОБ
                    ОРГАНИЗАЦИИ КОДА
                </p>
                <p>
                    Чтобы разобраться какие преймущества дает этот подход, рассмотрим основные ПРИНЦИПЫ ООП. Ты
                    наверняка о них слышал{' '}
                </p>
                <p>
                    По классике выделяют 3 принципа. Но в некоторых источниках число доходит до 8. Обозначим четыре.
                    Добавим абстрагирование
                </p>
                <p></p>
                <p>
                    <p>
                        <div>
                            Начну с абстрагирования. Это очень важное в ООП понятие. Так как именно оно лежит в основе
                            возможности расширения приложений. В основе классов тоже лежит некая астракция(интерфейс),
                            которая реализуется в наследовании
                        </div>
                        <strong>
                            Абстрагирование — это способ выделить набор значимых характеристик объекта, исключая из
                            рассмотрения не значимые.Соответственно, абстракция — это набор всех таких характеристик.{' '}
                        </strong>
                    </p>
                    <p>
                        <div>Наследование. Тут более-менее все должно быть ясно, хотя бы на интуитивном уровне.</div>
                        <strong>
                            Наследование — это свойство системы, позволяющее описать новый класс на основе уже
                            существующего с частично или полностью заимствующейся функциональностью. Класс, от которого
                            производится наследование, называется базовым, родительским или суперклассом. Новый класс —
                            потомком, наследником или производным классом
                        </strong>
                    </p>
                    <div>Ну и классический пример с машинками. </div>
                    <div>У нас есть класс - автомобиль.</div>
                    <div>И дочерний класс - хэтчбеки.</div>
                    Хэтчбэки наследуют у автомобиля 4 колеса, выхлопную трубу, способность ездить и прочие базовые
                    характеристики и умения автомобиля. При этом у него будут свои характеристики, свойственные именно
                    хэтчбеку.
                </p>
                <p>
                    С инкапсуляцией есть некоторые тонкости. Часто выделяют СОКРЫТИЕ ДАННЫХ как основной смысл
                    инкапсуляции, однако же сокрытие есть важный побочный продукт инкапсуляции. Суть в том, что
                    <div>
                        <strong>
                            Инкапсуляция — это свойство системы, позволяющее объединить данные и методы, работающие с
                            ними в классе
                        </strong>
                    </div>
                    <div>
                        или
                        <div>
                            <strong>
                                В информатике размещение в одном компоненте данных и методов, которые с ними работают.
                                Также может означать скрытие внутренней реализации от других компонентов. Например,
                                доступ к скрытой переменной может предоставляться не напрямую, а с помощью методов для
                                чтения и изменения её значения
                            </strong>
                        </div>
                    </div>
                    <div>
                        Инкапсуляция повзоляет выстраивать архитектуру. Разбивать на отдельные модули. Предоставляет
                        возможность удобства в пользовании компонентами. Обеспечивает безопасность сокрытием.
                    </div>
                </p>
                <p>
                    И наконец, его величество полиорфизм. Страшный дядька, которого в некоторых источниках выделяют как
                    столп ООП, называя принципы выше лишь его подспорьем.
                    <div>
                        Может, так оно и есть. Ведь именно полиморфизм задает ноту универсальности интерфейсов.
                        Позволяет выстраивать гибкую и расширяемую архитектуру.
                    </div>
                    <div>
                        Ведь основной смысл ООП в том, что благодаря ему мы можем превратить скромный туду-лист в
                        сложный многофункциональный органайзер по типу jira. При этом не сойдя с ума от того, что на
                        каком-то этапе новый функционал добавлять стало невроятно сложно, баги сыпятся как из рога
                        страданий,отловить их не может даже Чак Норрис, а запутаться в коде могут не только лишь все.{' '}
                    </div>
                    <div>
                        Определений, как и типов полиморфизма много. Пока не буду на этом заострять внимание. Приведу
                        наиболее лакончиные
                    </div>
                    <div>
                        <strong>
                            Полиморфизм — это свойство системы использовать объекты с одинаковым интерфейсом без
                            информации о типе и внутренней структуре объекта.
                        </strong>
                    </div>
                    <div>
                        <strong>Полиморфизм — способность функции обрабатывать данные разных типов.</strong>
                    </div>
                    <div>
                        <strong>
                            Полиморфизм — возможность объектов с одинаковой спецификацией иметь различную реализацию.
                        </strong>
                    </div>
                </p>

                <p></p>
                <p>Подведем итог.</p>
                <p>
                    Смысл ООП - выстраивании гибкой, расширяемой и надежной архитектуры. Но основе ООП строится{' '}
                    <Link to="/solid">solid</Link>. Которые повсеместно используются в создании приложений.
                </p>
            </div>
        ),
    },
    func: {
        link: '/func',
        content: (
            <div>
                <h3>Итак, ФП!</h3>
                <h3>Полезные видео по ФП в джс, сравнение имеративного и фс. Функторы, монады</h3>
                <div>
                    <iframe
                        width="560"
                        height="315"
                        src="https://www.youtube.com/embed/0JxSs_GcvbQ"
                        frameborder="0"
                        allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
                        allowfullscreen></iframe>
                </div>
                <b></b>
                <div>
                    <iframe
                        width="560"
                        height="315"
                        src="https://www.youtube.com/embed/3Z7f0Gi8pxw"
                        frameborder="0"
                        allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
                        allowfullscreen></iframe>
                </div>
                <h3>Вики говорит нам:</h3>
                <div>
                    <div>
                        <strong>
                            Функциона́льное программи́рование — раздел дискретной математики и парадигма программирования,
                            в которой процесс вычисления трактуется как вычисление значений функций в математическом
                            понимании последних (в отличие от функций как подпрограмм в процедурном программировании).
                        </strong>
                    </div>
                    <div>
                        <strong>
                            Противопоставляется парадигме императивного программирования, которая описывает процесс
                            вычислений как последовательное изменение состояний{' '}
                        </strong>
                        (в значении, подобном таковому в теории автоматов). При необходимости, в функциональном
                        программировании вся совокупность последовательных состояний вычислительного процесса
                        представляется явным образом, например, как список.
                    </div>
                    <div>
                        <strong>
                            Функциональное программирование предполагает обходиться вычислением результатов функций от
                            исходных данных и результатов других функций, и не предполагает явного хранения состояния
                            программы. Соответственно, не предполагает оно и изменяемость этого состояния (в отличие от
                            императивного, где одной из базовых концепций является переменная, хранящая своё значение и
                            позволяющая менять его по мере выполнения алгоритма).
                        </strong>
                    </div>
                    <div>
                        На практике отличие математической функции от понятия «функции» в императивном программировании
                        заключается в том, что императивные функции могут опираться не только на аргументы, но и на
                        состояние внешних по отношению к функции переменных, а также иметь побочные эффекты и менять
                        состояние внешних переменных. Таким образом,
                        <strong>
                            {' '}
                            в императивном программировании при вызове одной и той же функции с одинаковыми параметрами,
                            но на разных этапах выполнения алгоритма, можно получить разные данные на выходе из-за
                            влияния на функцию состояния переменных. А в функциональном языке при вызове функции с
                            одними и теми же аргументами мы всегда получим одинаковый результат: выходные данные зависят
                            только от входных.
                        </strong>{' '}
                        Это позволяет средам выполнения программ на функциональных языках кешировать результаты функций
                        и вызывать их в порядке, не определяемом алгоритмом и распараллеливать их без каких-либо
                        дополнительных действий со стороны программиста (что обеспечивают функции без побочных эффектов
                        — чистые функции).
                    </div>
                    <h3>Терминология</h3>
                    <div>
                        <strong>Функции высших порядков</strong>
                    </div>
                    <div>
                        <strong>
                            Функции высших порядков — это такие функции, которые могут принимать в качестве аргументов и
                            возвращать другие функции
                        </strong>
                        . Математики такую функцию чаще называют оператором, например, оператор взятия производной или
                        оператор интегрирования. Функции высших порядков позволяют использовать{' '}
                        <strong>
                            карринг — преобразование функции от пары аргументов в функцию, берущую свои аргументы по
                            одному.
                        </strong>{' '}
                        Это преобразование получило своё название в честь Х. Карри.
                    </div>
                    <p></p>
                    <div>
                        <strong>Чистые функции</strong>
                    </div>
                    <div>
                        <strong>
                            {' '}
                            Чистыми называют функции, которые не имеют побочных эффектов ввода-вывода и памяти (они
                            зависят только от своих параметров и возвращают только свой результат).
                        </strong>{' '}
                        Чистые функции обладают несколькими полезными свойствами, многие из которых можно использовать
                        для оптимизации кода:
                    </div>
                    <ul className="row list_style">
                        <li>
                            Если результат чистой функции не используется, её вызов может быть удалён без вреда для
                            других выражений.
                        </li>
                        <li>
                            Результат вызова чистой функции может быть мемоизирован, то есть сохранён в таблице значений
                            вместе с аргументами вызова. Если в дальнейшем функция вызывается с этими же аргументами, её
                            результат может быть взят прямо из таблицы, не вычисляясь (иногда это называется принципом
                            прозрачности ссылок). Мемоизация, ценой небольшого расхода памяти, позволяет существенно
                            увеличить производительность и уменьшить порядок роста некоторых рекурсивных алгоритмов.
                        </li>
                        <li>
                            Если нет никакой зависимости по данным между двумя чистыми функциями, то порядок их
                            вычисления можно поменять или распараллелить (говоря иначе вычисление чистых функций
                            удовлетворяет принципам thread-safe)
                        </li>
                        <li>
                            Если весь язык не допускает побочных эффектов, то можно использовать любую политику
                            вычисления. Это предоставляет свободу компилятору комбинировать и реорганизовывать
                            вычисление выражений в программе (например, исключить древовидные структуры).
                        </li>

                        <div>
                            <strong>Рекурсия</strong>
                        </div>
                        <div>
                            В функциональных языках цикл обычно реализуется в виде рекурсии. Строго говоря, в
                            функциональной парадигме программирования нет такого понятия, как цикл. Рекурсивные функции
                            вызывают сами себя, позволяя операции выполняться снова и снова.
                        </div>
                        <p></p>
                    </ul>
                    <p></p>
                    <h3>Особенности</h3>
                    <p>
                        <strong>
                            Императивные программы имеют склонность акцентировать последовательности шагов для
                            выполнения какого-то действия, а функциональные программы к расположению и композиции
                            функций, часто не обозначая точной последовательности шагов
                        </strong>
                    </p>
                    <p>
                        <strong>Основной особенностью</strong> функционального программирования, определяющей как
                        преимущества, так и недостатки данной парадигмы, является то, что в ней{' '}
                        <strong>реализуется модель вычислений без состояний.</strong> Если императивная программа на
                        любом этапе исполнения имеет состояние, то есть совокупность значений всех переменных, и
                        производит побочные эффекты, то{' '}
                        <strong>
                            чисто функциональная программа ни целиком, ни частями состояния не имеет и побочных эффектов
                            не производит.
                        </strong>{' '}
                        То, что в императивных языках делается путём присваивания значений переменным, в функциональных
                        достигается путём передачи выражений в параметры функций. Непосредственным следствием становится
                        то, что чисто функциональная программа не может изменять уже имеющиеся у неё данные, а может
                        лишь порождать новые путём копирования и/или расширения старых. Следствием того же является
                        отказ от циклов в пользу рекурсии.
                    </p>
                    <h3>Сильные стороны</h3>
                    <ul className="row list_style">
                        <li>
                            <p>
                                <strong>Повышение надёжности кода</strong>
                            </p>
                            Привлекательная сторона вычислений без состояний —{' '}
                            <strong>
                                повышение надёжности кода за счёт чёткой структуризации и отсутствия необходимости
                                отслеживания побочных эффектов. Любая функция работает только с локальными данными и
                                работает с ними всегда одинаково, независимо от того, где, как и при каких
                                обстоятельствах она вызывается. Невозможность мутации данных при пользовании ими в
                                разных местах программы исключает появление труднообнаруживаемых ошибок{' '}
                            </strong>
                            (таких, например, как случайное присваивание неверного значения глобальной переменной в
                            императивной программе).
                            <p></p>
                        </li>

                        <li>
                            <p>
                                <strong>Удобство организации модульного тестирования</strong>
                            </p>
                            Поскольку функция в функциональном программировании не может порождать побочные эффекты,
                            менять объекты нельзя как внутри области видимости, так и снаружи (в отличие от императивных
                            программ, где одна функция может установить какую-нибудь внешнюю переменную, считываемую
                            второй функцией). Единственным эффектом от вычисления функции является возвращаемый ей
                            результат, и единственный фактор, оказывающий влияние на результат — это значения
                            аргументов.
                            <div></div>
                            <strong>
                                Таким образом, имеется возможность протестировать каждую функцию в программе, просто
                                вычислив её от различных наборов значений аргументов. При этом можно не беспокоиться ни
                                о вызове функций в правильном порядке, ни о правильном формировании внешнего состояния.
                                Если любая функция в программе проходит модульные тесты, то можно быть уверенным в
                                качестве всей программы.
                            </strong>
                            В императивных программах проверка возвращаемого значения функции недостаточна: функция
                            может модифицировать внешнее состояние, которое тоже нужно проверять, чего не нужно делать в
                            функциональных программах.
                            <p></p>
                        </li>

                        <li>
                            <p>
                                <strong>Возможности оптимизации при компиляции</strong>
                            </p>
                            Традиционно упоминаемой положительной особенностью функционального программирования является
                            то, что оно позволяет описывать программу в так называемом «декларативном» виде, когда
                            жесткая последовательность выполнения многих операций, необходимых для вычисления
                            результата, в явном виде не задаётся, а формируется автоматически в процессе вычисления
                            функций. Это обстоятельство, а также отсутствие состояний даёт возможность применять к
                            функциональным программам достаточно сложные методы автоматической оптимизации.
                            <p></p>
                        </li>

                        <li>
                            <p>
                                <strong>Возможности параллелизма</strong>
                            </p>
                            Ещё одним преимуществом функциональных программ является то, что они предоставляют
                            широчайшие возможности для автоматического распараллеливания вычислений.{' '}
                            <strong>
                                Поскольку отсутствие побочных эффектов гарантировано, в любом вызове функции всегда
                                допустимо параллельное вычисление двух различных параметров — порядок их вычисления не
                                может оказать влияния на результат вызова.
                            </strong>
                            <p></p>
                        </li>
                    </ul>
                    <h3>Недостатки</h3>
                    <p></p>
                    Недостатки функционального программирования вытекают из тех же самых его особенностей. Отсутствие
                    присваиваний и замена их на порождение новых данных приводят к необходимости постоянного выделения и
                    автоматического освобождения памяти, поэтому в системе исполнения функциональной программы
                    обязательным компонентом становится высокоэффективный сборщик мусора. Нестрогая модель вычислений
                    приводит к непредсказуемому порядку вызова функций, что создаёт проблемы при вводе-выводе, где
                    порядок выполнения операций важен. Кроме того, очевидно, функции ввода в своём естественном виде
                    (например, getchar из стандартной библиотеки языка C) не являются чистыми, поскольку способны
                    возвращать различные значения для одних и тех же аргументов, и для устранения этого требуются
                    определённые ухищрения. Для преодоления недостатков функциональных программ уже первые языки
                    функционального программирования включали не только чисто функциональные средства, но и механизмы
                    императивного программирования (присваивание, цикл, «неявный PROGN» были уже в Лиспе). Использование
                    таких средств позволяет решить некоторые практические проблемы, но означает отход от идей (и
                    преимуществ) функционального программирования и написание императивных программ на функциональных
                    языках. В чистых функциональных языках эти проблемы решаются другими средствами, например, в языке
                    Haskell ввод-вывод реализован при помощи монад — нетривиальной концепции, позаимствованной из теории
                    категорий.
                </div>
                <p></p>
                <div>
                    <a href="https://habr.com/ru/post/142351/"> Более развернуто о ФП можно почитать тут</a>
                </div>
                <h3>Мякотка</h3>
                <p>
                    Ок,это все были общие положения относитльно ФП. Но что может показаться интерсным нам, как
                    js-разработчикам?
                </p>
                <div>
                    Смотрим <ScrollTo text="видео" top={150} left={0} /> тов. Шемсединова и читаем{' '}
                    <a href="https://tproger.ru/translations/functional-js-1/">статью эту </a>и{' '}
                    <a href="https://tproger.ru/translations/functional-js-2/">и эту </a>
                    чтобы разобраться что такое функторы и монады. Какие они бывают и какие задачи решают.{' '}
                </div>
                <h3>Функторы</h3>
                <p>
                    Если просто, функторы- это некая сущность(в js это можно реализовать через классы\протитипы\ и
                    замыкания) которая реализует метод map.
                    <div>
                        Вспоминаем Array.map и пониамем о чем идет речь - то, что возвращает НОВЫЙ МОДИФИЦИРОВАННЫЙ
                        объект
                    </div>
                    <div>
                        <img src={require('./assets/functor.png')} />
                    </div>
                    <div>
                        Обратим внимание на слово НОВЫЙ. Мы не мутируем, не изменяем текущий объект. Это одна из основ
                        ФП, как ясно из теории.
                    </div>
                    <div>
                        Наш map действует точно также, как и привычный в Array.prototype - он принимает некотрую функцию
                        и согласно ее алгоритму возвращает объект. Так что многие следовают функциональному стилю, даже
                        не задумываясь об этом. Также тут есть страховка, в виде проверки. Если чего-то не хватает -
                        вернем Null.
                    </div>
                    <h3>Монады</h3>
                    <p>
                        Монады — это подтип функторов, так как у них есть метод map, но они также реализуют другие
                        методы, например, ap, of, chain.
                        <div>
                            <img src={require('./assets/monad.png')} />
                        </div>
                    </p>
                </p>
                <h3>Выводы</h3>
                <div>
                    JS- мультипарадигменный язык, никто не мешает нам использовать лучшие практики с раличных парадигм и
                    совмещать их. Никто не заставляет писать чисто в одной парадигме.(да и писать чисто на ФП ===
                    невозможно, так как много токостей, допустим отрицание переменных)
                </div>
                <div>
                    Используя элмененты ФП мы можем избегать ошибок, свзанных с мутацией. Мы лучше контрлируем
                    происходящее. Мы можем упрощать юнит-тестирование. Создавая переиспользуемые функции, мы делаем код
                    лаконичней и красивее. Следуем принципу dry. Каррирование позволяет нам удобнее выстраивать систему
                    взаимодействия(основа паттерна декоратор в js).Ну а рекурсия обычно короче и красивей.
                </div>
            </div>
        ),
    },
    solid: {
        link: '/solid',
        content: (
            <div>
                <h2>Итак, solid!</h2>
                <h3>Хорошее видево от тов. Минина</h3>
                <iframe
                    id={'mininsolid'}
                    width="560"
                    height="315"
                    src="https://www.youtube.com/embed/xq13wiqvcTc"
                    frameborder="0"
                    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
                    allowfullscreen></iframe>
                <p></p>
                <p></p>
                <h3>Ну а начнем, пожалуй, по традиций с определений и вики</h3>
                <p>
                    <strong>
                        SOLID (сокр. от англ. single responsibility, open-closed, Liskov substitution, interface
                        segregation и dependency inversion) в программировании — мнемонический акроним, введённый
                        Майклом Фэзерсом (Michael Feathers) для первых пяти принципов, названных Робертом Мартином в
                        начале 2000-х, которые означали пять основных принципов объектно-ориентированного
                        программирования и проектирования.
                    </strong>
                </p>
                <h3>Назначение</h3>
                <p>
                    При создании программных систем использование принципов SOLID способствует созданию такой системы,
                    которую будет легко поддерживать и расширять в течение долгого времени. Принципы SOLID — это
                    руководства, которые также могут применяться во время работы над существующим программным
                    обеспечением для его улучшения - например для удаления «дурно пахнущего кода». Стратегии гибкой и
                    адаптивной разработки предполагают написание кода с соблюдением принципов SOLID.
                </p>

                <h3>Сами принципы КРАТКО</h3>

                <table>
                    <tr>
                        <th>Инициал</th>
                        <th>Название и суть</th>
                    </tr>
                    <tr>
                        <td>S</td>
                        <td>
                            Принцип единственной ответственности (The Single Responsibility Principle) Каждый объект
                            должен иметь одну ответственность и эта ответственность должна быть полностью
                            инкапсулирована в класс. Все его поведения должны быть направлены исключительно на
                            обеспечение этой ответственности.
                        </td>
                    </tr>
                    <tr>
                        <td>O</td>
                        <td>
                            Принцип открытости/закрытости (The Open Closed Principle) «программные сущности … должны
                            быть открыты для расширения, но закрыты для модификации.»
                        </td>
                    </tr>
                    <tr>
                        <td>L</td>
                        <td>
                            Принцип подстановки Барбары Лисков (The Liskov Substitution Principle) «объекты в программе
                            должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения
                            программы.» Наследующий класс должен дополнять, а не изменять базовый.
                        </td>
                    </tr>
                    <tr>
                        <td>I</td>
                        <td>
                            Принцип разделения интерфейса (The Interface Segregation Principle) «много интерфейсов,
                            специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»
                        </td>
                    </tr>
                    <tr>
                        <td>D</td>
                        <td>
                            Принцип инверсии зависимостей (The Dependency Inversion Principle) Модули верхних уровней не
                            должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
                            Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
                        </td>
                    </tr>
                </table>
                <h3>Звучит несомненно замечательно. Но что со всем эти делать?(кроме как выпендриваться на собесах)</h3>
                <p>
                    Тов. Минин, я вызываю тебя! Далее материал будет на основе{' '}
                    <ScrollTo text="урока" top={20} left={0} /> ибо хорошо разложено для js{' '}
                </p>
                <p>
                    <strong>The Single Responsibility Principle</strong>
                </p>
                <p>
                    Суть такова: если надо расширить класс новым функционалом. Добавить новое поведение. Лучше вынести
                    это поведение в отдельный класс.
                </p>
                <p>И пример от маэстро</p>
                <p>
                    Ниже описывается класс news. В нем инкапсулированы только те сущности, котроые отвечают
                    непосредственно за новость: контент и возможность обновления. С этой новостью мы можем делать что
                    хотим: отобразить на странице в html, передать в json, xml и тд. И можно в классе news задать методы
                    обработки в нужный формат. Можно, да. Тогда мы будем нарушать наш принцип.
                    <strong>Почему это не хорошо? Почему следует вынести обработчик в одельный класс?</strong>
                </p>
                <p>
                    <strong>
                        Во первых мы не перегружаем сам класс. Он остается лаконичным и понятным. Во вторых мы создаем
                        универсальный класс -обрабочтик, которым могут пользоваться другие классы, помимо news.{' '}
                    </strong>
                    <div>
                        {' '}
                        ->В примере обработчик конренто для news и принимает экземпляр news. Но чисто теоретически можно
                        эктраполировать на что угодно.
                    </div>
                </p>
                <a href="https://github.com/vladilenm/SOLID_javascript/blob/master/1_S.js">Ссылка на пример</a>
                <p></p>
                <p>Мнение вики</p>
                <p>
                    <strong>
                        Возникает вопрос, когда стоит использовать этот принцип? Всё же принцип — это не закон и SRP
                        стоит применять в зависимости от того, как изменяется приложение:
                    </strong>
                </p>

                <div>
                    {' '}
                    -если при изменении кода, отвечающего за одну ответственность, в приложении появляются исправления
                    кода, отвечающего за другую ответственность, то это первый сигнал о нарушении SRP.
                </div>
                <div>
                    {' '}
                    -если же изменения кода, отвечающего за одну ответственность, не вносят изменения в код, отвечающий
                    за другую ответственность, то этот принцип можно не применять.
                </div>
                <p></p>
                <p>
                    Слепое следование принципу единственной ответственности приводит к избыточной сложности приложения,
                    его поддержки и тестирования. SRP стоит применять только тогда, когда это оправдано. Принцип SRP
                    можно применить только в том случае, когда:
                </p>

                <div> -объекту класса становится позволительно слишком много;</div>
                <div> -доменная логика концентрируется только в одном классе;</div>
                <div>
                    {' '}
                    -любое изменение логики поведения объекта приводит к изменениям в других местах приложения, где это
                    не подразумевалось изначально;
                </div>
                <div>
                    {' '}
                    -приходится тестировать, исправлять ошибки, компилировать различные места приложения, даже если за
                    их работоспособность отвечает третья сторона;
                </div>
                <div>
                    {' '}
                    -невозможно легко отделить и применить класс в другой сфере приложения, так как это потянет ненужные
                    зависимости.
                </div>

                <div>
                    <p></p>
                    <strong>
                        Объединение ответственностей является общепринятой практикой и в этом нет ничего плохого, до тех
                        пор пока это легко обслуживать. Следование принципу единственной ответственности зависит от
                        функций программного продукта и является труднейшим при проектировании приложений.
                    </strong>
                </div>
                <p></p>
                <p>
                    Прочитав все и ознакомившись с примером, ты дорогой читатель мог и запутаться. Когда стоит, а когда
                    не стоит применять этот принцип в js. Понимание придет с опытом. На мой взляд не стоит пихать этот
                    принцип всюду и дробить все подряд. Как критерием может послужить момент из{' '}
                    <Link to="/oop">ооп</Link>. А именно абстрагирование. Насколько поведение можно назвать значимым
                    неосредственно для конкретного класса. И можно ли это поведение абстрагировать от класса и применить
                    к другому классу. Если нет\да - то тогда можно применить принцип. (Мое мнение)
                </p>
                <p></p>
                <p>
                    <strong>The Open Closed Principle</strong>
                </p>
                <p>
                    Классы должны быть ОТКРЫТЫ для РАСШИРЕНИЯ и ЗАКРЫТЫ для МОДИФИКАЦИИ
                    <div>
                        <strong>
                            Смысл принципа в том, что мы выстраиваеи код таким образом, что если нам протребуется
                            добавить какие-либо возможности и новый функционал то мы НЕ ПЕРЕПИСЫВАЕМ старый код.
                        </strong>
                        <p>
                            В примере у нас есть фигуры и класс, который считает площади. Этот класс мог бесконечно
                            модифицироваться ифами с появлением новых классов фигур. Это больно. Поэтому мы не
                            переписываем логику класса площадей, а вводим базовый класс для фигур, который повзоляет
                            возвращать площадь. А класс площадей универсально их принимает и выдает результат.
                            <strong>
                                Каждая новая фигура требует РАСШИРЕНИЕ числa дочерних классов фигуры, а не МОДИФИЦИКАЦИИ
                                класса площадей.
                            </strong>
                            <a href="https://github.com/vladilenm/SOLID_javascript/blob/master/2_O.js">Пример</a>
                        </p>
                        <p></p>
                        <p>
                            <strong>The Liskov Substitution Principle</strong>
                        </p>
                        <p>
                            <div>Вики подкидывает нам размышления несколько философского толка:</div>
                            Принцип Барбары Лисков заставляет задуматься о том, что такое «декларация типа» в терминах
                            объектно-ориентированного языка программирования, который мы используем. Достаточно ли нам
                            описать интерфейс объекта с помощью обычного абстрактного класса со списком методов, типами
                            параметров и возвращаемого значения? Каким образом мы можем декларировать требования к
                            значениям параметров метода и свойства, которыми будет обладать возвращаемое значение? Как
                            нам описать исключения, которые может сгенерировать метод во время выполнения? Как нам
                            описать изменение состояния объекта на разных этапах его жизненного цикла? Задавая себе эти
                            вопросы и находя ответы, можно спроектировать систему, которая действительно будет
                            удовлетворять принципу подстановки Барбары Лисков.
                        </p>
                        <p>
                            <strong>
                                Роберт С. Мартин определил этот принцип так: Функции, которые используют базовый тип,
                                должны иметь возможность использовать подтипы базового типа, не зная об этом.
                            </strong>
                        </p>
                        <p>
                            <div>
                                Cуть в том, что функция должна уметь работать как с базовым типом, так с его потомками
                                одинаково.
                            </div>
                            Тов. Минин привел пример с классом Person от которого наследуются сотрудники двух разных
                            компаний. Одни имеют доступ к секретной двери. Другие нет. Так вот функция, которая
                            проверяет на доступ выбрасывае ошибку на тех ребятах, которые из другой компании. Хотя
                            принимает она во всех случаях person. Ведь именно класс person содержит инфу о ключе. Это и
                            нарушает принцип Liskov substitution. Для решения проблемы мы вводим новый уровень
                            абстракции. Person получает двух наследников. Собтсвенно члены компании и гости. И уже на
                            этом уровне, в этих двух классах мы и определяем ключи. А секретная дверь будет работать уже
                            с ними.
                            <div>
                                Во втором примере показана работа с компонентами. Когда компоненты разных типов
                                наследовались от класса components который содержал render метод. Проблема возникла,
                                когда появился hoc, тоесть компонент который "отключает" рендер, так как мы знаем что
                                hocи не имеют редер\а если не знаем читаем\. Соответсвенно на функции rendercomponent,
                                которая использовала render от components выбрасывается ошибка. Алгоритм аналогичный -
                                вводим новый уровень абстракции и переносим render туда где он нужен. RenderComponent
                                будет работать только с этим классом.
                            </div>
                            <a href="https://github.com/vladilenm/SOLID_javascript/blob/master/3_L.js">Примеры</a>
                        </p>
                        <p>
                            <strong>The Interface Segregation Principle</strong>
                        </p>
                        <div>Вики</div>
                        <p>
                            <strong>
                                Роберт С. Мартин определил этот принцип так: Программные сущности не должны зависеть от
                                методов, которые они не используют. Принцип разделения интерфейсов говорит о том, что
                                слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические,
                                чтобы программные сущности маленьких интерфейсов знали только о методах, которые
                                необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться
                                программные сущности, которые этот метод не используют.
                            </strong>
                            <div>
                                Следование этому принципу помогает системе оставаться гибкой при внесении изменений в
                                логику работы и пригодной для рефакторинга.
                            </div>
                        </p>
                        <p>
                            Суть в том, что если наследник не использует метод, который он получил от родителя,
                            использует не корректно, значит мы сделали что-то не так
                        </p>
                        <div>
                            Тов. Минин привел очень наглядный пример с животными. Базовый класс Animal содержал в себе
                            методы- спосбности животных. Но наследник собака не умеет летать. А такой метод есть в
                            базоом классе. Пришлось "обнулять" его. Вместо этого автор предложил использовал композицию,
                            благодаря которой можно добавлять только нужные умения.
                            <a href="https://github.com/vladilenm/SOLID_javascript/blob/master/4_I.js">Пример</a>
                        </div>
                    </div>
                </p>
                <p>
                    <strong>The Dependency Inversion Principle</strong>
                </p>
                <p>
                    <strong>
                        Формулировка:
                        <div>
                            Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны
                            зависеть от абстракций.
                        </div>
                        <div>Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.</div>
                    </strong>
                </p>
                <p>
                    Тов. Минин привел живой пример, где база данных получала данные из разных источников. Первоначально
                    это был условный фетч. И класс ДБ первоначально вызывал экземпляр фетча. Но потом вяснилось что
                    данные подтягиваются с локалстараджа, поэтому ДБ пришлось переписать.
                    <div>На лицо зависимость абстракции от деталей</div>
                    Устраняем это введением новых абстракций, отвечающих за конкретный тип, с которыми и будет работать
                    ДБ.
                    <a href="https://github.com/vladilenm/SOLID_javascript/blob/master/5_D.js">Пример</a>
                </p>
            </div>
        ),
    },
    kiss: {
        link: 'link',
        content: (
            <div>
                <h3>KISS</h3>
                <div style={{ marginTop: '70px' }}>
                    KISS (акроним для «Keep it simple, stupid») — принцип проектирования, принятый в ВМС США в 1960.
                    Принцип KISS утверждает, что большинство систем работают лучше всего, если они остаются простыми, а
                    не усложняются. Поэтому в области проектирования простота должна быть одной из ключевых целей, и
                    следует избегать ненужной сложности. Фраза ассоциировалась с авиаконструктором Кларенсом Джонсоном
                    (1910—1990)[3]. В 1970-х гг. широко использовался термин «KISS-принцип» (англ. KISS principle)[4].
                    Вариации на фразу включают «англ. Keep it Simple, Silly», «keep it short and simple», «keep it
                    simple and straightforward» и «keep it small and simple».
                </div>
                <div>
                    <img
                        src={require('./assets/kiss.jpg')}
                        style={{ width: '130px', position: 'absolute', top: 0, right: 0 }}
                    />{' '}
                </div>
                <p>Итак. Что же такое KISS?</p>
                <p>
                    Это не только замечательный вокально-инструментальный ансамбль,но и важный для разработчика принцип
                </p>
                Расписано <a href="https://web-creator.ru/articles/kiss">тут</a> Но для тех кому лень переходить по
                ссылку скопипастю. Ибо смысла пояснять что-либо нет. Все предельно ясно.
                <h3>Принцип программирования KISS — делайте вещи проще</h3>
                <p>
                    Большая часть программных систем необосновано перегружена практически ненужными функциями, что
                    ухудшает удобство их использование конечными пользователями, а также усложняет их поддержку и
                    развитие разработчиками. Следование принципу «KISS» позволяет разрабатывать решения, которые просты
                    в использовании и в сопровождении.
                </p>
                <p>
                    KISS — это принцип проектирования и программирования, при котором простота системы декларируется в
                    качестве основной цели или ценности. Есть два варианта расшифровки аббревиатуры: «keep it simple,
                    stupid» и более корректный «keep it short and simple».
                </p>
                <h3>В проектировании следование принципу KISS выражается в том, что:</h3>
                <ul className="list_style row">
                    <li>
                        не имеет смысла реализовывать дополнительные функции, которые не будут использоваться вовсе или
                        их использование крайне маловероятно, как правило, большинству пользователей достаточно базового
                        функционала, а усложнение только вредит удобству приложения;
                    </li>
                    <li>
                        не стоит перегружать интерфейс теми опциями, которые не будут нужны большинству пользователей,
                        гораздо проще предусмотреть для них отдельный «расширенный» интерфейс (или вовсе отказаться от
                        данного функционала);
                    </li>
                    <li>
                        бессмысленно делать реализацию сложной бизнес-логики, которая учитывает абсолютно все возможные
                        варианты поведения системы, пользователя и окружающей среды, — во-первых, это просто невозможно,
                        а во-вторых, такая фанатичность заставляет собирать «звездолёт», что чаще всего иррационально с
                        коммерческой точки зрения.
                    </li>
                </ul>
                <h3>В программировании следование принципу KISS можно описать так(наматываем на ус!):</h3>
                <ul className="list_style row">
                    <li>
                        не имеет смысла беспредельно увеличивать уровень абстракции, надо уметь вовремя остановиться;
                    </li>
                    <li>
                        бессмысленно закладывать в проект избыточные функции «про запас», которые может быть
                        когда-нибудь кому-либо понадобятся
                    </li>
                    <li>не стоит подключать огромную библиотеку, если вам от неё нужна лишь пара функций;</li>
                    <li>декомпозиция чего-то сложного на простые составляющие — это архитектурно верный подход</li>
                    <li>
                        абсолютная математическая точность или предельная детализация нужны не всегда — большинство
                        систем создаются не для запуска космических шаттлов, данные можно и нужно обрабатывать с той
                        точностью, которая достаточна для качественного решения задачи, а детализацию выдавать в нужном
                        пользователю объёме, а не в максимально возможном объёме.
                    </li>
                </ul>
                Размышления по теме <a href="https://habr.com/ru/post/249639/">Здесь</a>
                <p>Мякотка с этой статьи:</p>
                <p>
                    <strong>
                        Итак, принцип проектирования KISS (keep it simple and straightforward) провозглашает, что
                        простота кода – превыше всего, потому что простой код – наиболее понятный.
                    </strong>
                    Практически все принципы проектирования направлены на достижение понятности кода. Нарушая какой-либо
                    принцип проектирования, вы уменьшаете понятность кода. Непонятный код автоматически вызывает у
                    человека ощущение того, что код сложный, так как его сложно понимать и модифицировать. При нарушении
                    любого из этих принципов также нарушается и принцип KISS. Поэтому можно говорить, что KISS включает
                    почти все остальные принципы проектирования. Патерны проектирования описывают наиболее удачные,
                    простые и понятные решения некоторых проблем. Если вы используете паттерн проектирования там, где
                    нет проблемы, которую решает данный паттерн – то вы нарушаете KISS, внося ненужные усложнения в код.
                    Если вы НЕ используете паттерн проектирования там, где есть проблема, соответствующая паттерну – то
                    вы опять-таки нарушаете KISS, делая код сложнее, чем он мог бы быть.
                </p>
                <p>
                    <strong>На мой взгляд, принцип KISS может быть полезен лишь для начинающих проектировщиков</strong>,
                    которые не знают или не понимают основных принципов проектирования. KISS защищает от неверного
                    использования принципов проектирования и паттернов. Поскольку принципы и паттерны предназначены для
                    увеличения понятности кода, то их правильное использование не может привести к уменьшению понятности
                    кода. Однако если вы неверно понимаете принцип проектирования (например, истолковываете «не плодите
                    лишних сущностей» как «плодите как можно меньше сущностей»), или соблюдая один принцип нарушаете
                    десяток других, то KISS может стать для вас надёжной подушкой безопасности. В остальных случаях от
                    KISS-а мало толку, т.к. он слишком общий и абстрактный. Остальные же принципы более конкретны и
                    содержат более явные пути к достижению понятности и простоты кода.
                </p>
                <p>
                    Всвязи с тем, что представления разных людей о таком понятии как «простота» могут различаться,
                    приобрели широкое распространение
                    <strong> следующая заблуждения относительно KISS-a:</strong>
                    <div>
                        {' '}
                        Заблуждение 1. Если считать, что простой код – это такой код, который проще всего написать, то
                        можно истолковать, что принцип KISS призывает писать первое что взбредёт в голову, вообще не
                        задумываясь о проектировании.
                    </div>
                    <div>
                        Заблуждение 2. Если считать, что простой код – это такой код, для написания которого требуется
                        как можно меньше знаний, то можно истолковать, что принцип KISS призывает не использовать
                        паттерны проектирования.{' '}
                    </div>
                </p>
            </div>
        ),
    },
    yagni: {
        link: '/yagni',
        content: (
            <div>
                <h3>Принцип программирования YAGNI — «Вам это не понадобится»</h3>
                <p>
                    {' '}
                    <a href="https://web-creator.ru/articles/yagni">статья</a>
                </p>
                <p>
                    Если упрощенно, то следование данному принципу заключается в том, что возможности, которые не
                    описаны в требованиях к системе, просто не должны реализовываться. Это позволяет вести разработку,
                    руководствуясь экономическими критериями — Заказчик не должен оплачивать ненужные ему функции, а
                    разработчики не должны тратить своё оплачиваемое время на реализацию того, что не требуется.
                </p>
                <p>
                    Основная проблема, которую решает принцип YAGNI — это устранение тяги программистов к излишней
                    абстракции, к экспериментам «из интереса» и к реализации функционала, который сейчас не нужен, но,
                    по мнению разработчика, может либо вскоре понадобиться, либо просто будет полезен, хотя в реальности
                    такого очень часто не происходит.
                </p>
                <p>
                    «Бесплатных» функций в программных продуктах просто не бывает. Если рассматривать материальную
                    сторону, то любые ненужные, но фактически реализованные «фичи» оплачиваются либо Заказчиком (в
                    бюджет закладываются расходы на те функции, которые не нужны), либо Исполнителем из прибыли по
                    проекту. И тот, и другой варианты с точки зрения бизнеса неверны. Если же говорить о нематериальных
                    затратах, то любые «бонусные» возможности усложняют сопровождение, увеличивают вероятность ошибок и
                    усложняют взаимодействие с продуктом, — между объёмом кодовой базы и описанными характеристиками
                    есть прямая зависимость. Больше написанного кода — труднее сопровождать и выше вероятность появления
                    «багов», тут очень уместна поговорка: «лучший код — это ненаписанный код».
                </p>
                <p>
                    Принципы YAGNI и <Link to="/kiss">KISS</Link> очень похожи, если <Link to="/kiss">KISS</Link>{' '}
                    нацелен на упрощение и полезен в плане работы с теми требованиями, которые имеют место быть, то
                    YAGNI более категоричен и применяется для ограждения проектов по разработке ПО от «размывания» их
                    рамок.
                </p>
                <p>
                    <strong>
                        Подход к реализации проектов строго по ТЗ верен с нескольких ракурсов. Заказчик не должен
                        платить за то, что ему не надо, а продукт должен быть максимально сопровождаем и его качество не
                        должно страдать от интеграции ненужных функций.
                    </strong>
                </p>
            </div>
        ),
    },
    dry: {
        link: '/dry',
        content: (
            <div>
                <h3>Принцип программирования DRY — don’t repeat yourself / не повторяйте себя</h3>
                <p>
                    <a href="https://web-creator.ru/articles/dry">Статья</a>
                </p>
                <p>
                    Следование принципу программирования «DRY» позволяет добиться высокой сопровождаемости проекта,
                    простоты внесения изменений и качественного тестирования.
                </p>
                <p>
                    Если код не дублируется, то для изменения логики достаточно внесения исправлений всего в одном месте
                    и проще тестировать одну (пусть и более сложную) функцию, а не набор из десятков однотипных.
                    Следование принципу DRY всегда приводит к декомпозиции сложных алгоритмов на простые функции. А
                    декомпозиция сложных операций на более простые (и повторно используемые) значительно упрощает
                    понимание программного кода. Повторное использование функций, вынесенных из сложных алгоритмов,
                    позволяет сократить время разработки и тестирования новой функциональности.
                </p>
                <p>
                    Следование принципу DRY приводит к модульной архитектуре приложения и к чёткому разделению
                    ответственности за бизнес-логику между программными классами. А это — залог сопровождаемой
                    архитектуры. Хотя чаще не DRY приводит к модульности, а уже модульность, в свою очередь,
                    обеспечивает принципиальную возможность соблюдения этого принципа в больших проектах.
                </p>

                <p>
                    В рамках одного программного класса (или модуля) следовать DRY и не повторяться обычно достаточно
                    просто. Также не требует титанических усилий делать это в рамках небольших проектов, где все
                    разработчики «владеют» всем кодом системы. А вот в больших проектах ситуация с DRY несколько сложнее
                    — повторы чаще всего появляются из-за отсутствия у разработчиков целостной картины или
                    несогласованности действий в рамках команды. Следовать принципу «don’t repeat yourself» в рамках
                    больших проектов не так просто, как это может показаться на первый взгляд. От разработчиков
                    требуется тщательное планирование архитектуры, а от архитектора или тимлида требуется наличие
                    видения системы в целом и чёткая постановка задач разработчикам.
                </p>

                <p>
                    В пректировании DRY тоже имеет место — доступ к конкретному функционалу должен быть доступен в одном
                    месте, унифицирован и сгруппирован по какому-либо принципу, а не «разбросан» по системе в
                    произвольных вариациях. Этот подход пересекается с принципом единственной ответственности из пяти
                    принципов SOLID, сформулированных Робертом Мартином.
                </p>
            </div>
        ),
    },
    datastructures: {
        link: '/datastructures',
        content: (
            <div>
                <h3>Структуры данных</h3>
                <p>
                    Мякотка(даже скорее опорный конспект)
                    <a href="https://habr.com/ru/post/310794/">этого материала</a>
                </p>
                <p>Что нам дадут эти знания?</p>
                <div>
                    Штмл верстальщику/jquery developer-у из 2013, быть может и ничего. Но мускулистому разработчику
                    позволит:
                </div>
                <ul className="row list_style">
                    <li>Управлять сложностью своих программ, делая их доступней для понимания.</li>
                    <li>Создавать высокопроизводительные программы, эффективно работающие с памятью.</li>
                </ul>
                <h3>Что такое структуры данных?</h3>
                <p>
                    По сути, это способы хранить и организовывать данные, чтобы эффективней решать различные задачи.
                    Данные можно представить по-разному. В зависимости от того, что это за данные и что вы собираетесь с
                    ними делать, одно представление подойдёт лучше других.
                </p>

                <h3>Алгоритмы</h3>

                <div>Алгоритм — такое хитроумное название для последовательности совершаемых действий.</div>
                <div>
                    Структуры данных реализованы с помощью алгоритмов, алгоритмы — с помощью структур данных. Всё
                    состоит из структур данных и алгоритмов, вплоть до уровня, на котором бегают микроскопические
                    человечки с перфокартами и заставляют компьютер работать. Любая данная задача реализуется
                    бесконечным количеством способов. Как следствие, для решения распространённых задач изобрели
                    множество различных алгоритмов. Например, для сортировки неупорядоченного множества элементов
                    существует до смешного большое количество алгоритмов:{' '}
                </div>

                <div>
                    <ul className="list_style">
                        <li>
                            <a href="https://habr.com/ru/post/335920/">
                                Сортировка вставками, Сортировка выбором, Сортировка слиянием, Сортировка пузырьком,
                                Cортировка кучи, Быстрая сортировка, Сортировка Шелла, Сортировка Тима, Блочная
                                сортировка, Поразрядная сортировка...
                            </a>
                        </li>
                    </ul>
                </div>

                <div>
                    Некоторые из них значительно быстрее остальных. Другие занимают меньше памяти. Третьи легко
                    реализовать. Четвёртые построены на допущениях относительно наборов данных.
                </div>

                <div>
                    Каждая из сортировок подходит лучше других для определённой задачи. Поэтому вам надо будет сперва
                    решить, какие у вас потребности и критерии, чтобы понять, как сравнивать алгоритмы между собой.
                </div>

                <div>
                    Для сравнения производительности алгоритмов используется грубое измерение средней производительности
                    и производительности в худшем случае, для обозначения которых используется термин
                    <a href="https://webdevblog.ru/bolshoe-o-chto-eto-takoe-pochemu-eto-vazhno-i-pochemu-eto-ne-vazhno/">
                        {' '}
                        «О» большое.
                    </a>
                </div>

                <div>
                    «О» большое — обозначение способа приблизительной оценки производительности алгоритмов для
                    относительного сравнения.
                </div>

                <div>
                    О большое — заимствованное информатикой математические обозначение, определяющее, как алгоритмы
                    соотносятся с передаваемым им некоторым количеством N данных.
                </div>

                <div>О большое характеризует две основные величины:</div>

                <div>
                    Оценка времени выполнения — общее количество операций, которое алгоритм проведёт на данном множестве
                    данных.
                </div>

                <div>
                    Оценка объёма — общее количество памяти, требующееся алгоритму для обработки данного множества
                    данных.
                </div>

                <div>
                    Оценки делаются независимо друг от друга: одни алгоритмы могут производить меньше операций, чем
                    другие, занимая при этом больше памяти. Определив свои требования, вы сможете выбрать
                    соответствующий алгоритм.
                </div>

                <h3>Вот некоторые распространённые значения О большого:</h3>

                <p>взято с ориг истончика</p>
                <div>
                    <img src={require('./assets/obig.png')} />
                </div>
                <h3>Структуры данных непосредственно</h3>
                <p>разделим на две группы: использующие память напрмую и реализующие другие структуры данных</p>
                <h3>Напрямую</h3>
                <p>Списки</p>
                <p>Хэш - таблицы</p>
                <h3>Через другие</h3>
                <p>Стэки</p>
                <p>Графы</p>
                <p>Связанные списки</p>
                <p>Деревья</p>
                <p></p>
            </div>
        ),
    },
    adaptive: {
        link: '/adaptive',
        content: (
            <div>
                <h3>Виды медиа запросов</h3>
                <p>
                    <iframe
                        width="560"
                        height="315"
                        src="https://www.youtube.com/embed/XbnAKjjlgc4?start=1362"
                        frameborder="0"
                        allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
                        allowfullscreen></iframe>
                </p>
            </div>
        ),
    },
    jsnotes: {
        link: '/jsnotes',
        content: (
            <div>
                <h3>Заметки по js</h3>
                <ol className="row list_style">
                    <li>proto - ссылка на прототип объекта</li>
                    <li>
                        <a href="https://developer.mozilla.org/ru/docs/Web/API/Console/group">console.group</a>
                    </li>
                    <li>
                        Упоротый пример. Контекст при привзяки мы берем в момент ВЫЗОВА А так как функия вне объекта
                        привязываем ее к window
                        <img src={require('./assets/uprt.png')} />
                    </li>
                    <li>
                        <a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D">
                            Ивент луп. IventLoop наглядно
                        </a>
                    </li>
                    <li>
                        PromiseAll вывод: сначала ретурны в МАССИВЕ.
                        <img src={require('./assets/promiseall.png')} />
                        Это свяано с порядком выполнения операций. Микротаски и макротаски.
                    </li>
                    <li>
                        Object.create может принимать второй аргумент. Объект. Однако значения ключей он принимает уже
                        не явно. А через дескрипторы.
                        <div>Пример маэстро</div>
                        <img src={require('./assets/descr.png')} />
                        <div></div>
                        <a href="https://learn.javascript.ru/descriptors-getters-setters">Статья про дескрипторы</a>
                    </li>
                    <li>
                        <a href="https://jsonplaceholder.typicode.com/">api</a> для тестирования работы с запросами
                    </li>
                </ol>
            </div>
        ),
    },
    reactnotes: {
        link: '/reactnotes',
        content: (
            <div>
                <h3>Заметки по react</h3>
                <ol className="row list_style">
                    <li>
                        <a href="https://habr.com/ru/post/351168/">Статья про thunk и saga</a>
                    </li>
                    <li>
                        <a href="https://www.robinwieruch.de/react-render-props">render in props pattern</a>
                    </li>
                    <li>
                        <a href="https://habr.com/ru/company/ruvds/blog/428081/">RxJx React</a>
                    </li>
                </ol>
            </div>
        ),
    },
    others: {
        link: '/others',
        content: (
            <div>
                <h3>Прочие технологии</h3>
                <ol className="row list_style">
                    <li>
                        <a href="https://habr.com/ru/company/ruvds/blog/341880/">RxJx представление, </a>
                        <a href="https://medium.com/@toshabely/rxjs-%D1%81-%D0%BD%D1%83%D0%BB%D1%8F-%D0%BE%D0%B1%D0%B7%D0%BE%D1%80-%D0%BE%D0%B1%D0%BE%D0%B7%D1%80%D0%B5%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F-ca4d8e5fb386">
                            RxJx подробнее__но все равно нихрена не ясно,{' '}
                        </a>
                        <a href="https://habr.com/ru/post/438642/">почитаем это </a>
                    </li>
                </ol>
                <h3>Пример с реализацией rxjs</h3>
                <Gh />
            </div>
        ),
    },
};

export default Articles;
