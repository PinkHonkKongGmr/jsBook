import React from 'react';
import { Link } from 'react-router-dom';
import ScrollTo from '../helperComponent/scrollTo';
import Gh from '../hocs/gh';

const Articles = {
    oop: {
        link: '/oop',
        content: (
            <div>
                <h2>Итак, ооп!</h2>
                <p>
                    Начнем с сухих определений. Далеко лазить не будем. Откроем википедию и посмотрим что она скажет нам
                    об ООП
                </p>
                <p>
                    <strong>
                        Объе́ктно-ориенти́рованное программи́рование (ООП) — методология программирования, основанная на
                        представлении программы в виде совокупности объектов, каждый из которых является экземпляром
                        определённого класса, а классы образуют иерархию наследования.
                    </strong>
                </p>
                <p>
                    Спасибо, википедия, из этого мы можем сделать вывод что ООП оперирует обьектами, каждый объект несет
                    ряд свойств и характеристик, по которым их можно объеденить. Тоесть у кажого объекта есть свой
                    класс. Мы можем создавать новые объекты, наделяя их определенным классом. Это значит что новый
                    объект получит(унаследует) всю мощь объекта - прородителя
                </p>
                <p>Хорошо. Но мы, как умные ребята и правильные посоны изучим и другие источники</p>
                <p>
                    <strong>
                        Центральными в ООП являются понятия класса и объекта. Образно говоря, ООП заключается не столько
                        в использовании классов и объектов в программе, сколько в замене принципа программирования "от
                        функции к функции" принципом программирования "от класса к классу". Технология ООП прежде всего
                        накладывает ограничения на способы представления данных в программе. Любая программа отражает в
                        них состояние физических предметов либо абстрактных понятий (назовем их объектами
                        программирования), для работы с которыми она предназначена. В традиционной технологии варианты
                        представления данных могут быть разными. В худшем случае программист может "равномерно
                        размазать" данные о некотором объекте программирования по всей программе. В противоположность
                        этому все данные об объекте программирования и его связях с другими объектами можно объединить в
                        одну структурированную переменную. В первом приближении ее можно назвать объектом. Кроме того, с
                        объектом связывается набор действий, иначе называемых методами. С точки зрения языка
                        программирования это функции, получающие в качестве обязательного параметра указатель на объект.
                        Технология ООП запрещает работать с объектом иначе, чем через методы, то есть внутренняя
                        структура объекта скрыта от внешнего пользователя. Описание множества однотипных объектов
                        называется классом. Объект - структурированная переменная, содержащая всю информацию о некотором
                        физическом предмете или реализуемом в программе понятии. Класс - описание множества таких
                        объектов и выполняемых над ними действий.
                    </strong>
                </p>

                <p>
                    Очень хорошо, так мы приходим к пониманию, что ООП это не столько про классы, сколько про СПОСОБ
                    ОРГАНИЗАЦИИ КОДА
                </p>
                <p>
                    Чтобы разобраться какие преймущества дает этот подход, рассмотрим основные ПРИНЦИПЫ ООП. Ты
                    наверняка о них слышал{' '}
                </p>
                <p>
                    По классике выделяют 3 принципа. Но в некоторых источниках число доходит до 8. Обозначим четыре.
                    Добавим абстрагирование
                </p>
                <p></p>
                <p>
                    <p>
                        <div>
                            Начну с абстрагирования. Это очень важное в ООП понятие. Так как именно оно лежит в основе
                            возможности расширения приложений. В основе классов тоже лежит некая астракция(интерфейс),
                            которая реализуется в наследовании
                        </div>
                        <strong>
                            Абстрагирование — это способ выделить набор значимых характеристик объекта, исключая из
                            рассмотрения не значимые.Соответственно, абстракция — это набор всех таких характеристик.{' '}
                        </strong>
                    </p>
                    <p>
                        <div>Наследование. Тут более-менее все должно быть ясно, хотя бы на интуитивном уровне.</div>
                        <strong>
                            Наследование — это свойство системы, позволяющее описать новый класс на основе уже
                            существующего с частично или полностью заимствующейся функциональностью. Класс, от которого
                            производится наследование, называется базовым, родительским или суперклассом. Новый класс —
                            потомком, наследником или производным классом
                        </strong>
                    </p>
                    <div>Ну и классический пример с машинками. </div>
                    <div>У нас есть класс - автомобиль.</div>
                    <div>И дочерний класс - хэтчбеки.</div>
                    Хэтчбэки наследуют у автомобиля 4 колеса, выхлопную трубу, способность ездить и прочие базовые
                    характеристики и умения автомобиля. При этом у него будут свои характеристики, свойственные именно
                    хэтчбеку.
                </p>
                <p>
                    С инкапсуляцией есть некоторые тонкости. Часто выделяют СОКРЫТИЕ ДАННЫХ как основной смысл
                    инкапсуляции, однако же сокрытие есть важный побочный продукт инкапсуляции. Суть в том, что
                    <div>
                        <strong>
                            Инкапсуляция — это свойство системы, позволяющее объединить данные и методы, работающие с
                            ними в классе
                        </strong>
                    </div>
                    <div>
                        или
                        <div>
                            <strong>
                                В информатике размещение в одном компоненте данных и методов, которые с ними работают.
                                Также может означать скрытие внутренней реализации от других компонентов. Например,
                                доступ к скрытой переменной может предоставляться не напрямую, а с помощью методов для
                                чтения и изменения её значения
                            </strong>
                        </div>
                    </div>
                    <div>
                        Инкапсуляция повзоляет выстраивать архитектуру. Разбивать на отдельные модули. Предоставляет
                        возможность удобства в пользовании компонентами. Обеспечивает безопасность сокрытием.
                    </div>
                </p>
                <p>
                    И наконец, его величество полиорфизм. Страшный дядька, которого в некоторых источниках выделяют как
                    столп ООП, называя принципы выше лишь его подспорьем.
                    <div>
                        Может, так оно и есть. Ведь именно полиморфизм задает ноту универсальности интерфейсов.
                        Позволяет выстраивать гибкую и расширяемую архитектуру.
                    </div>
                    <div>
                        Ведь основной смысл ООП в том, что благодаря ему мы можем превратить скромный туду-лист в
                        сложный многофункциональный органайзер по типу jira. При этом не сойдя с ума от того, что на
                        каком-то этапе новый функционал добавлять стало невроятно сложно, баги сыпятся как из рога
                        страданий,отловить их не может даже Чак Норрис, а запутаться в коде могут не только лишь все.{' '}
                    </div>
                    <div>
                        Определений, как и типов полиморфизма много. Пока не буду на этом заострять внимание. Приведу
                        наиболее лакончиные
                    </div>
                    <div>
                        <strong>
                            Полиморфизм — это свойство системы использовать объекты с одинаковым интерфейсом без
                            информации о типе и внутренней структуре объекта.
                        </strong>
                    </div>
                    <div>
                        <strong>Полиморфизм — способность функции обрабатывать данные разных типов.</strong>
                    </div>
                    <div>
                        <strong>
                            Полиморфизм — возможность объектов с одинаковой спецификацией иметь различную реализацию.
                        </strong>
                    </div>
                </p>

                <p></p>
                <p>Подведем итог.</p>
                <p>
                    Смысл ООП - выстраивании гибкой, расширяемой и надежной архитектуры. Но основе ООП строится{' '}
                    <Link to="/solid">solid</Link>. Которые повсеместно используются в создании приложений.
                </p>
                <div>
                    хорошая <a href="https://habr.com/ru/post/463125/">статья</a>
                </div>
            </div>
        ),
    },
    func: {
        link: '/func',
        content: (
            <div>
                <h3>Итак, ФП!</h3>
                <h3>Полезные видео по ФП в джс, сравнение имеративного и фс. Функторы, монады</h3>
                <div>
                    <iframe
                        width="560"
                        height="315"
                        src="https://www.youtube.com/embed/0JxSs_GcvbQ"
                        frameborder="0"
                        allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
                        allowfullscreen></iframe>
                </div>
                <b></b>
                <div>
                    <iframe
                        width="560"
                        height="315"
                        src="https://www.youtube.com/embed/3Z7f0Gi8pxw"
                        frameborder="0"
                        allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
                        allowfullscreen></iframe>
                </div>
                <h3>Вики говорит нам:</h3>
                <div>
                    <div>
                        <strong>
                            Функциона́льное программи́рование — раздел дискретной математики и парадигма программирования,
                            в которой процесс вычисления трактуется как вычисление значений функций в математическом
                            понимании последних (в отличие от функций как подпрограмм в процедурном программировании).
                        </strong>
                    </div>
                    <div>
                        <strong>
                            Противопоставляется парадигме императивного программирования, которая описывает процесс
                            вычислений как последовательное изменение состояний{' '}
                        </strong>
                        (в значении, подобном таковому в теории автоматов). При необходимости, в функциональном
                        программировании вся совокупность последовательных состояний вычислительного процесса
                        представляется явным образом, например, как список.
                    </div>
                    <div>
                        <strong>
                            Функциональное программирование предполагает обходиться вычислением результатов функций от
                            исходных данных и результатов других функций, и не предполагает явного хранения состояния
                            программы. Соответственно, не предполагает оно и изменяемость этого состояния (в отличие от
                            императивного, где одной из базовых концепций является переменная, хранящая своё значение и
                            позволяющая менять его по мере выполнения алгоритма).
                        </strong>
                    </div>
                    <div>
                        На практике отличие математической функции от понятия «функции» в императивном программировании
                        заключается в том, что императивные функции могут опираться не только на аргументы, но и на
                        состояние внешних по отношению к функции переменных, а также иметь побочные эффекты и менять
                        состояние внешних переменных. Таким образом,
                        <strong>
                            {' '}
                            в императивном программировании при вызове одной и той же функции с одинаковыми параметрами,
                            но на разных этапах выполнения алгоритма, можно получить разные данные на выходе из-за
                            влияния на функцию состояния переменных. А в функциональном языке при вызове функции с
                            одними и теми же аргументами мы всегда получим одинаковый результат: выходные данные зависят
                            только от входных.
                        </strong>{' '}
                        Это позволяет средам выполнения программ на функциональных языках кешировать результаты функций
                        и вызывать их в порядке, не определяемом алгоритмом и распараллеливать их без каких-либо
                        дополнительных действий со стороны программиста (что обеспечивают функции без побочных эффектов
                        — чистые функции).
                    </div>
                    <h3>Терминология</h3>
                    <div>
                        <strong>Функции высших порядков</strong>
                    </div>
                    <div>
                        <strong>
                            Функции высших порядков — это такие функции, которые могут принимать в качестве аргументов и
                            возвращать другие функции
                        </strong>
                        . Математики такую функцию чаще называют оператором, например, оператор взятия производной или
                        оператор интегрирования. Функции высших порядков позволяют использовать{' '}
                        <strong>
                            карринг — преобразование функции от пары аргументов в функцию, берущую свои аргументы по
                            одному.
                        </strong>{' '}
                        Это преобразование получило своё название в честь Х. Карри.
                    </div>
                    <p></p>
                    <div>
                        <strong>Чистые функции</strong>
                    </div>
                    <a href="https://ru.hexlet.io/courses/introduction_to_programming/lessons/pure/theory_unit">
                        Про чистые функции от hexet
                    </a>
                    <div>
                        <strong>
                            {' '}
                            Чистыми называют функции, которые не имеют побочных эффектов ввода-вывода и памяти (они
                            зависят только от своих параметров и возвращают только свой результат).
                        </strong>{' '}
                        Чистые функции обладают несколькими полезными свойствами, многие из которых можно использовать
                        для оптимизации кода:
                    </div>
                    <ul className="row list_style">
                        <li>
                            Если результат чистой функции не используется, её вызов может быть удалён без вреда для
                            других выражений.
                        </li>
                        <li>
                            Результат вызова чистой функции может быть мемоизирован, то есть сохранён в таблице значений
                            вместе с аргументами вызова. Если в дальнейшем функция вызывается с этими же аргументами, её
                            результат может быть взят прямо из таблицы, не вычисляясь (иногда это называется принципом
                            прозрачности ссылок). Мемоизация, ценой небольшого расхода памяти, позволяет существенно
                            увеличить производительность и уменьшить порядок роста некоторых рекурсивных алгоритмов.
                        </li>
                        <li>
                            Если нет никакой зависимости по данным между двумя чистыми функциями, то порядок их
                            вычисления можно поменять или распараллелить (говоря иначе вычисление чистых функций
                            удовлетворяет принципам thread-safe)
                        </li>
                        <li>
                            Если весь язык не допускает побочных эффектов, то можно использовать любую политику
                            вычисления. Это предоставляет свободу компилятору комбинировать и реорганизовывать
                            вычисление выражений в программе (например, исключить древовидные структуры).
                        </li>

                        <div>
                            <strong>Рекурсия</strong>
                        </div>
                        <div>
                            В функциональных языках цикл обычно реализуется в виде рекурсии. Строго говоря, в
                            функциональной парадигме программирования нет такого понятия, как цикл. Рекурсивные функции
                            вызывают сами себя, позволяя операции выполняться снова и снова.
                        </div>
                        <p></p>
                    </ul>
                    <p></p>
                    <h3>Особенности</h3>
                    <p>
                        <strong>
                            Императивные программы имеют склонность акцентировать последовательности шагов для
                            выполнения какого-то действия, а функциональные программы к расположению и композиции
                            функций, часто не обозначая точной последовательности шагов
                        </strong>
                    </p>
                    <p>
                        <strong>Основной особенностью</strong> функционального программирования, определяющей как
                        преимущества, так и недостатки данной парадигмы, является то, что в ней{' '}
                        <strong>реализуется модель вычислений без состояний.</strong> Если императивная программа на
                        любом этапе исполнения имеет состояние, то есть совокупность значений всех переменных, и
                        производит побочные эффекты, то{' '}
                        <strong>
                            чисто функциональная программа ни целиком, ни частями состояния не имеет и побочных эффектов
                            не производит.
                        </strong>{' '}
                        То, что в императивных языках делается путём присваивания значений переменным, в функциональных
                        достигается путём передачи выражений в параметры функций. Непосредственным следствием становится
                        то, что чисто функциональная программа не может изменять уже имеющиеся у неё данные, а может
                        лишь порождать новые путём копирования и/или расширения старых. Следствием того же является
                        отказ от циклов в пользу рекурсии.
                    </p>
                    <h3>Сильные стороны</h3>
                    <ul className="row list_style">
                        <li>
                            <p>
                                <strong>Повышение надёжности кода</strong>
                            </p>
                            Привлекательная сторона вычислений без состояний —{' '}
                            <strong>
                                повышение надёжности кода за счёт чёткой структуризации и отсутствия необходимости
                                отслеживания побочных эффектов. Любая функция работает только с локальными данными и
                                работает с ними всегда одинаково, независимо от того, где, как и при каких
                                обстоятельствах она вызывается. Невозможность мутации данных при пользовании ими в
                                разных местах программы исключает появление труднообнаруживаемых ошибок{' '}
                            </strong>
                            (таких, например, как случайное присваивание неверного значения глобальной переменной в
                            императивной программе).
                            <p></p>
                        </li>

                        <li>
                            <p>
                                <strong>Удобство организации модульного тестирования</strong>
                            </p>
                            Поскольку функция в функциональном программировании не может порождать побочные эффекты,
                            менять объекты нельзя как внутри области видимости, так и снаружи (в отличие от императивных
                            программ, где одна функция может установить какую-нибудь внешнюю переменную, считываемую
                            второй функцией). Единственным эффектом от вычисления функции является возвращаемый ей
                            результат, и единственный фактор, оказывающий влияние на результат — это значения
                            аргументов.
                            <div></div>
                            <strong>
                                Таким образом, имеется возможность протестировать каждую функцию в программе, просто
                                вычислив её от различных наборов значений аргументов. При этом можно не беспокоиться ни
                                о вызове функций в правильном порядке, ни о правильном формировании внешнего состояния.
                                Если любая функция в программе проходит модульные тесты, то можно быть уверенным в
                                качестве всей программы.
                            </strong>
                            В императивных программах проверка возвращаемого значения функции недостаточна: функция
                            может модифицировать внешнее состояние, которое тоже нужно проверять, чего не нужно делать в
                            функциональных программах.
                            <p></p>
                        </li>

                        <li>
                            <p>
                                <strong>Возможности оптимизации при компиляции</strong>
                            </p>
                            Традиционно упоминаемой положительной особенностью функционального программирования является
                            то, что оно позволяет описывать программу в так называемом «декларативном» виде, когда
                            жесткая последовательность выполнения многих операций, необходимых для вычисления
                            результата, в явном виде не задаётся, а формируется автоматически в процессе вычисления
                            функций. Это обстоятельство, а также отсутствие состояний даёт возможность применять к
                            функциональным программам достаточно сложные методы автоматической оптимизации.
                            <p></p>
                        </li>

                        <li>
                            <p>
                                <strong>Возможности параллелизма</strong>
                            </p>
                            Ещё одним преимуществом функциональных программ является то, что они предоставляют
                            широчайшие возможности для автоматического распараллеливания вычислений.{' '}
                            <strong>
                                Поскольку отсутствие побочных эффектов гарантировано, в любом вызове функции всегда
                                допустимо параллельное вычисление двух различных параметров — порядок их вычисления не
                                может оказать влияния на результат вызова.
                            </strong>
                            <p></p>
                        </li>
                    </ul>
                    <h3>Недостатки</h3>
                    <p></p>
                    Недостатки функционального программирования вытекают из тех же самых его особенностей. Отсутствие
                    присваиваний и замена их на порождение новых данных приводят к необходимости постоянного выделения и
                    автоматического освобождения памяти, поэтому в системе исполнения функциональной программы
                    обязательным компонентом становится высокоэффективный сборщик мусора. Нестрогая модель вычислений
                    приводит к непредсказуемому порядку вызова функций, что создаёт проблемы при вводе-выводе, где
                    порядок выполнения операций важен. Кроме того, очевидно, функции ввода в своём естественном виде
                    (например, getchar из стандартной библиотеки языка C) не являются чистыми, поскольку способны
                    возвращать различные значения для одних и тех же аргументов, и для устранения этого требуются
                    определённые ухищрения. Для преодоления недостатков функциональных программ уже первые языки
                    функционального программирования включали не только чисто функциональные средства, но и механизмы
                    императивного программирования (присваивание, цикл, «неявный PROGN» были уже в Лиспе). Использование
                    таких средств позволяет решить некоторые практические проблемы, но означает отход от идей (и
                    преимуществ) функционального программирования и написание императивных программ на функциональных
                    языках. В чистых функциональных языках эти проблемы решаются другими средствами, например, в языке
                    Haskell ввод-вывод реализован при помощи монад — нетривиальной концепции, позаимствованной из теории
                    категорий.
                </div>
                <p></p>
                <div>
                    <a href="https://habr.com/ru/post/142351/"> Более развернуто о ФП можно почитать тут</a>
                </div>
                <h3>Мякотка</h3>
                <p>
                    Ок,это все были общие положения относитльно ФП. Но что может показаться интерсным нам, как
                    js-разработчикам?
                </p>
                <div>
                    Смотрим <ScrollTo text="видео" top={150} left={0} /> тов. Шемсединова и читаем{' '}
                    <a href="https://tproger.ru/translations/functional-js-1/">статью эту </a>и{' '}
                    <a href="https://tproger.ru/translations/functional-js-2/">и эту </a>
                    чтобы разобраться что такое функторы и монады. Какие они бывают и какие задачи решают.{' '}
                </div>
                <h3>Функторы</h3>
                <p>
                    Если просто, функторы- это некая сущность(в js это можно реализовать через классы\протитипы\ и
                    замыкания) которая реализует метод map.
                    <div>
                        Вспоминаем Array.map и пониамем о чем идет речь - то, что возвращает НОВЫЙ МОДИФИЦИРОВАННЫЙ
                        объект
                    </div>
                    <div>
                        <img src={require('./assets/functor.png')} />
                    </div>
                    <div>
                        Обратим внимание на слово НОВЫЙ. Мы не мутируем, не изменяем текущий объект. Это одна из основ
                        ФП, как ясно из теории.
                    </div>
                    <div>
                        Наш map действует точно также, как и привычный в Array.prototype - он принимает некотрую функцию
                        и согласно ее алгоритму возвращает объект. Так что многие следовают функциональному стилю, даже
                        не задумываясь об этом. Также тут есть страховка, в виде проверки. Если чего-то не хватает -
                        вернем Null.
                    </div>
                    <h3>Монады</h3>
                    <p>
                        Монады — это подтип функторов, так как у них есть метод map, но они также реализуют другие
                        методы, например, ap, of, chain.
                        <div>
                            <img src={require('./assets/monad.png')} />
                        </div>
                    </p>
                </p>
                <h3>Выводы</h3>
                <div>
                    JS- мультипарадигменный язык, никто не мешает нам использовать лучшие практики с раличных парадигм и
                    совмещать их. Никто не заставляет писать чисто в одной парадигме.(да и писать чисто на ФП ===
                    невозможно, так как много токостей, допустим отрицание переменных)
                </div>
                <div>
                    Используя элмененты ФП мы можем избегать ошибок, свзанных с мутацией. Мы лучше контрлируем
                    происходящее. Мы можем упрощать юнит-тестирование. Создавая переиспользуемые функции, мы делаем код
                    лаконичней и красивее. Следуем принципу dry. Каррирование позволяет нам удобнее выстраивать систему
                    взаимодействия(основа паттерна декоратор в js).Ну а рекурсия обычно короче и красивей.
                </div>
            </div>
        ),
    },
    solid: {
        link: '/solid',
        content: (
            <div>
                <h2>Итак, solid!</h2>
                <h3>Хорошее видево от тов. Минина</h3>
                <iframe
                    id={'mininsolid'}
                    width="560"
                    height="315"
                    src="https://www.youtube.com/embed/xq13wiqvcTc"
                    frameborder="0"
                    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
                    allowfullscreen></iframe>
                <p></p>
                <p></p>
                <h3>Ну а начнем, пожалуй, по традиций с определений и вики</h3>
                <p>
                    <strong>
                        SOLID (сокр. от англ. single responsibility, open-closed, Liskov substitution, interface
                        segregation и dependency inversion) в программировании — мнемонический акроним, введённый
                        Майклом Фэзерсом (Michael Feathers) для первых пяти принципов, названных Робертом Мартином в
                        начале 2000-х, которые означали пять основных принципов объектно-ориентированного
                        программирования и проектирования.
                    </strong>
                </p>
                <h3>Назначение</h3>
                <p>
                    При создании программных систем использование принципов SOLID способствует созданию такой системы,
                    которую будет легко поддерживать и расширять в течение долгого времени. Принципы SOLID — это
                    руководства, которые также могут применяться во время работы над существующим программным
                    обеспечением для его улучшения - например для удаления «дурно пахнущего кода». Стратегии гибкой и
                    адаптивной разработки предполагают написание кода с соблюдением принципов SOLID.
                </p>

                <h3>Сами принципы КРАТКО</h3>

                <table>
                    <tr>
                        <th>Инициал</th>
                        <th>Название и суть</th>
                    </tr>
                    <tr>
                        <td>S</td>
                        <td>
                            Принцип единственной ответственности (The Single Responsibility Principle) Каждый объект
                            должен иметь одну ответственность и эта ответственность должна быть полностью
                            инкапсулирована в класс. Все его поведения должны быть направлены исключительно на
                            обеспечение этой ответственности.
                        </td>
                    </tr>
                    <tr>
                        <td>O</td>
                        <td>
                            Принцип открытости/закрытости (The Open Closed Principle) «программные сущности … должны
                            быть открыты для расширения, но закрыты для модификации.»
                        </td>
                    </tr>
                    <tr>
                        <td>L</td>
                        <td>
                            Принцип подстановки Барбары Лисков (The Liskov Substitution Principle) «объекты в программе
                            должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения
                            программы.» Наследующий класс должен дополнять, а не изменять базовый.
                        </td>
                    </tr>
                    <tr>
                        <td>I</td>
                        <td>
                            Принцип разделения интерфейса (The Interface Segregation Principle) «много интерфейсов,
                            специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»
                        </td>
                    </tr>
                    <tr>
                        <td>D</td>
                        <td>
                            Принцип инверсии зависимостей (The Dependency Inversion Principle) Модули верхних уровней не
                            должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
                            Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
                        </td>
                    </tr>
                </table>
                <h3>Звучит несомненно замечательно. Но что со всем эти делать?(кроме как выпендриваться на собесах)</h3>
                <p>
                    Тов. Минин, я вызываю тебя! Далее материал будет на основе{' '}
                    <ScrollTo text="урока" top={20} left={0} /> ибо хорошо разложено для js{' '}
                </p>
                <p>
                    <strong>The Single Responsibility Principle</strong>
                </p>
                <p>
                    Суть такова: если надо расширить класс новым функционалом. Добавить новое поведение. Лучше вынести
                    это поведение в отдельный класс.
                </p>
                <p>И пример от маэстро</p>
                <p>
                    Ниже описывается класс news. В нем инкапсулированы только те сущности, котроые отвечают
                    непосредственно за новость: контент и возможность обновления. С этой новостью мы можем делать что
                    хотим: отобразить на странице в html, передать в json, xml и тд. И можно в классе news задать методы
                    обработки в нужный формат. Можно, да. Тогда мы будем нарушать наш принцип.
                    <strong>Почему это не хорошо? Почему следует вынести обработчик в одельный класс?</strong>
                </p>
                <p>
                    <strong>
                        Во первых мы не перегружаем сам класс. Он остается лаконичным и понятным. Во вторых мы создаем
                        универсальный класс -обрабочтик, которым могут пользоваться другие классы, помимо news.{' '}
                    </strong>
                    <div>
                        {' '}
                        ->В примере обработчик конренто для news и принимает экземпляр news. Но чисто теоретически можно
                        эктраполировать на что угодно.
                    </div>
                </p>
                <a href="https://github.com/vladilenm/SOLID_javascript/blob/master/1_S.js">Ссылка на пример</a>
                <p></p>
                <p>Мнение вики</p>
                <p>
                    <strong>
                        Возникает вопрос, когда стоит использовать этот принцип? Всё же принцип — это не закон и SRP
                        стоит применять в зависимости от того, как изменяется приложение:
                    </strong>
                </p>

                <div>
                    {' '}
                    -если при изменении кода, отвечающего за одну ответственность, в приложении появляются исправления
                    кода, отвечающего за другую ответственность, то это первый сигнал о нарушении SRP.
                </div>
                <div>
                    {' '}
                    -если же изменения кода, отвечающего за одну ответственность, не вносят изменения в код, отвечающий
                    за другую ответственность, то этот принцип можно не применять.
                </div>
                <p></p>
                <p>
                    Слепое следование принципу единственной ответственности приводит к избыточной сложности приложения,
                    его поддержки и тестирования. SRP стоит применять только тогда, когда это оправдано. Принцип SRP
                    можно применить только в том случае, когда:
                </p>

                <div> -объекту класса становится позволительно слишком много;</div>
                <div> -доменная логика концентрируется только в одном классе;</div>
                <div>
                    {' '}
                    -любое изменение логики поведения объекта приводит к изменениям в других местах приложения, где это
                    не подразумевалось изначально;
                </div>
                <div>
                    {' '}
                    -приходится тестировать, исправлять ошибки, компилировать различные места приложения, даже если за
                    их работоспособность отвечает третья сторона;
                </div>
                <div>
                    {' '}
                    -невозможно легко отделить и применить класс в другой сфере приложения, так как это потянет ненужные
                    зависимости.
                </div>

                <div>
                    <p></p>
                    <strong>
                        Объединение ответственностей является общепринятой практикой и в этом нет ничего плохого, до тех
                        пор пока это легко обслуживать. Следование принципу единственной ответственности зависит от
                        функций программного продукта и является труднейшим при проектировании приложений.
                    </strong>
                </div>
                <p></p>
                <p>
                    Прочитав все и ознакомившись с примером, ты дорогой читатель мог и запутаться. Когда стоит, а когда
                    не стоит применять этот принцип в js. Понимание придет с опытом. На мой взляд не стоит пихать этот
                    принцип всюду и дробить все подряд. Как критерием может послужить момент из{' '}
                    <Link to="/oop">ооп</Link>. А именно абстрагирование. Насколько поведение можно назвать значимым
                    неосредственно для конкретного класса. И можно ли это поведение абстрагировать от класса и применить
                    к другому классу. Если нет\да - то тогда можно применить принцип. (Мое мнение)
                </p>
                <p></p>
                <p>
                    <strong>The Open Closed Principle</strong>
                </p>
                <p>
                    Классы должны быть ОТКРЫТЫ для РАСШИРЕНИЯ и ЗАКРЫТЫ для МОДИФИКАЦИИ
                    <div>
                        <strong>
                            Смысл принципа в том, что мы выстраиваеи код таким образом, что если нам протребуется
                            добавить какие-либо возможности и новый функционал то мы НЕ ПЕРЕПИСЫВАЕМ старый код.
                        </strong>
                        <p>
                            В примере у нас есть фигуры и класс, который считает площади. Этот класс мог бесконечно
                            модифицироваться ифами с появлением новых классов фигур. Это больно. Поэтому мы не
                            переписываем логику класса площадей, а вводим базовый класс для фигур, который повзоляет
                            возвращать площадь. А класс площадей универсально их принимает и выдает результат.
                            <strong>
                                Каждая новая фигура требует РАСШИРЕНИЕ числa дочерних классов фигуры, а не МОДИФИЦИКАЦИИ
                                класса площадей.
                            </strong>
                            <a href="https://github.com/vladilenm/SOLID_javascript/blob/master/2_O.js">Пример</a>
                        </p>
                        <p></p>
                        <p>
                            <strong>The Liskov Substitution Principle</strong>
                        </p>
                        <p>
                            <div>Вики подкидывает нам размышления несколько философского толка:</div>
                            Принцип Барбары Лисков заставляет задуматься о том, что такое «декларация типа» в терминах
                            объектно-ориентированного языка программирования, который мы используем. Достаточно ли нам
                            описать интерфейс объекта с помощью обычного абстрактного класса со списком методов, типами
                            параметров и возвращаемого значения? Каким образом мы можем декларировать требования к
                            значениям параметров метода и свойства, которыми будет обладать возвращаемое значение? Как
                            нам описать исключения, которые может сгенерировать метод во время выполнения? Как нам
                            описать изменение состояния объекта на разных этапах его жизненного цикла? Задавая себе эти
                            вопросы и находя ответы, можно спроектировать систему, которая действительно будет
                            удовлетворять принципу подстановки Барбары Лисков.
                        </p>
                        <p>
                            <strong>
                                Роберт С. Мартин определил этот принцип так: Функции, которые используют базовый тип,
                                должны иметь возможность использовать подтипы базового типа, не зная об этом.
                            </strong>
                        </p>
                        <p>
                            <div>
                                Cуть в том, что функция должна уметь работать как с базовым типом, так с его потомками
                                одинаково.
                            </div>
                            Тов. Минин привел пример с классом Person от которого наследуются сотрудники двух разных
                            компаний. Одни имеют доступ к секретной двери. Другие нет. Так вот функция, которая
                            проверяет на доступ выбрасывае ошибку на тех ребятах, которые из другой компании. Хотя
                            принимает она во всех случаях person. Ведь именно класс person содержит инфу о ключе. Это и
                            нарушает принцип Liskov substitution. Для решения проблемы мы вводим новый уровень
                            абстракции. Person получает двух наследников. Собтсвенно члены компании и гости. И уже на
                            этом уровне, в этих двух классах мы и определяем ключи. А секретная дверь будет работать уже
                            с ними.
                            <div>
                                Во втором примере показана работа с компонентами. Когда компоненты разных типов
                                наследовались от класса components который содержал render метод. Проблема возникла,
                                когда появился hoc, тоесть компонент который "отключает" рендер, так как мы знаем что
                                hocи не имеют редер\а если не знаем читаем\. Соответсвенно на функции rendercomponent,
                                которая использовала render от components выбрасывается ошибка. Алгоритм аналогичный -
                                вводим новый уровень абстракции и переносим render туда где он нужен. RenderComponent
                                будет работать только с этим классом.
                            </div>
                            <a href="https://github.com/vladilenm/SOLID_javascript/blob/master/3_L.js">Примеры</a>
                        </p>
                        <p>
                            <strong>The Interface Segregation Principle</strong>
                        </p>
                        <div>Вики</div>
                        <p>
                            <strong>
                                Роберт С. Мартин определил этот принцип так: Программные сущности не должны зависеть от
                                методов, которые они не используют. Принцип разделения интерфейсов говорит о том, что
                                слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические,
                                чтобы программные сущности маленьких интерфейсов знали только о методах, которые
                                необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться
                                программные сущности, которые этот метод не используют.
                            </strong>
                            <div>
                                Следование этому принципу помогает системе оставаться гибкой при внесении изменений в
                                логику работы и пригодной для рефакторинга.
                            </div>
                        </p>
                        <p>
                            Суть в том, что если наследник не использует метод, который он получил от родителя,
                            использует не корректно, значит мы сделали что-то не так
                        </p>
                        <div>
                            Тов. Минин привел очень наглядный пример с животными. Базовый класс Animal содержал в себе
                            методы- спосбности животных. Но наследник собака не умеет летать. А такой метод есть в
                            базоом классе. Пришлось "обнулять" его. Вместо этого автор предложил использовал композицию,
                            благодаря которой можно добавлять только нужные умения.
                            <a href="https://github.com/vladilenm/SOLID_javascript/blob/master/4_I.js">Пример</a>
                        </div>
                    </div>
                </p>
                <p>
                    <strong>The Dependency Inversion Principle</strong>
                </p>
                <p>
                    <strong>
                        Формулировка:
                        <div>
                            Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны
                            зависеть от абстракций.
                        </div>
                        <div>Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.</div>
                    </strong>
                </p>
                <p>
                    Тов. Минин привел живой пример, где база данных получала данные из разных источников. Первоначально
                    это был условный фетч. И класс ДБ первоначально вызывал экземпляр фетча. Но потом вяснилось что
                    данные подтягиваются с локалстараджа, поэтому ДБ пришлось переписать.
                    <div>На лицо зависимость абстракции от деталей</div>
                    Устраняем это введением новых абстракций, отвечающих за конкретный тип, с которыми и будет работать
                    ДБ.
                    <a href="https://github.com/vladilenm/SOLID_javascript/blob/master/5_D.js">Пример</a>
                </p>
            </div>
        ),
    },
    kiss: {
        link: 'link',
        content: (
            <div>
                <h3>KISS</h3>
                <div style={{ marginTop: '70px' }}>
                    KISS (акроним для «Keep it simple, stupid») — принцип проектирования, принятый в ВМС США в 1960.
                    Принцип KISS утверждает, что большинство систем работают лучше всего, если они остаются простыми, а
                    не усложняются. Поэтому в области проектирования простота должна быть одной из ключевых целей, и
                    следует избегать ненужной сложности. Фраза ассоциировалась с авиаконструктором Кларенсом Джонсоном
                    (1910—1990)[3]. В 1970-х гг. широко использовался термин «KISS-принцип» (англ. KISS principle)[4].
                    Вариации на фразу включают «англ. Keep it Simple, Silly», «keep it short and simple», «keep it
                    simple and straightforward» и «keep it small and simple».
                </div>
                <div>
                    <img
                        src={require('./assets/kiss.jpg')}
                        style={{ width: '130px', position: 'absolute', top: 0, right: 0 }}
                    />{' '}
                </div>
                <p>Итак. Что же такое KISS?</p>
                <p>
                    Это не только замечательный вокально-инструментальный ансамбль,но и важный для разработчика принцип
                </p>
                Расписано <a href="https://web-creator.ru/articles/kiss">тут</a> Но для тех кому лень переходить по
                ссылку скопипастю. Ибо смысла пояснять что-либо нет. Все предельно ясно.
                <h3>Принцип программирования KISS — делайте вещи проще</h3>
                <p>
                    Большая часть программных систем необосновано перегружена практически ненужными функциями, что
                    ухудшает удобство их использование конечными пользователями, а также усложняет их поддержку и
                    развитие разработчиками. Следование принципу «KISS» позволяет разрабатывать решения, которые просты
                    в использовании и в сопровождении.
                </p>
                <p>
                    KISS — это принцип проектирования и программирования, при котором простота системы декларируется в
                    качестве основной цели или ценности. Есть два варианта расшифровки аббревиатуры: «keep it simple,
                    stupid» и более корректный «keep it short and simple».
                </p>
                <h3>В проектировании следование принципу KISS выражается в том, что:</h3>
                <ul className="list_style row">
                    <li>
                        не имеет смысла реализовывать дополнительные функции, которые не будут использоваться вовсе или
                        их использование крайне маловероятно, как правило, большинству пользователей достаточно базового
                        функционала, а усложнение только вредит удобству приложения;
                    </li>
                    <li>
                        не стоит перегружать интерфейс теми опциями, которые не будут нужны большинству пользователей,
                        гораздо проще предусмотреть для них отдельный «расширенный» интерфейс (или вовсе отказаться от
                        данного функционала);
                    </li>
                    <li>
                        бессмысленно делать реализацию сложной бизнес-логики, которая учитывает абсолютно все возможные
                        варианты поведения системы, пользователя и окружающей среды, — во-первых, это просто невозможно,
                        а во-вторых, такая фанатичность заставляет собирать «звездолёт», что чаще всего иррационально с
                        коммерческой точки зрения.
                    </li>
                </ul>
                <h3>В программировании следование принципу KISS можно описать так(наматываем на ус!):</h3>
                <ul className="list_style row">
                    <li>
                        не имеет смысла беспредельно увеличивать уровень абстракции, надо уметь вовремя остановиться;
                    </li>
                    <li>
                        бессмысленно закладывать в проект избыточные функции «про запас», которые может быть
                        когда-нибудь кому-либо понадобятся
                    </li>
                    <li>не стоит подключать огромную библиотеку, если вам от неё нужна лишь пара функций;</li>
                    <li>декомпозиция чего-то сложного на простые составляющие — это архитектурно верный подход</li>
                    <li>
                        абсолютная математическая точность или предельная детализация нужны не всегда — большинство
                        систем создаются не для запуска космических шаттлов, данные можно и нужно обрабатывать с той
                        точностью, которая достаточна для качественного решения задачи, а детализацию выдавать в нужном
                        пользователю объёме, а не в максимально возможном объёме.
                    </li>
                </ul>
                Размышления по теме <a href="https://habr.com/ru/post/249639/">Здесь</a>
                <p>Мякотка с этой статьи:</p>
                <p>
                    <strong>
                        Итак, принцип проектирования KISS (keep it simple and straightforward) провозглашает, что
                        простота кода – превыше всего, потому что простой код – наиболее понятный.
                    </strong>
                    Практически все принципы проектирования направлены на достижение понятности кода. Нарушая какой-либо
                    принцип проектирования, вы уменьшаете понятность кода. Непонятный код автоматически вызывает у
                    человека ощущение того, что код сложный, так как его сложно понимать и модифицировать. При нарушении
                    любого из этих принципов также нарушается и принцип KISS. Поэтому можно говорить, что KISS включает
                    почти все остальные принципы проектирования. Патерны проектирования описывают наиболее удачные,
                    простые и понятные решения некоторых проблем. Если вы используете паттерн проектирования там, где
                    нет проблемы, которую решает данный паттерн – то вы нарушаете KISS, внося ненужные усложнения в код.
                    Если вы НЕ используете паттерн проектирования там, где есть проблема, соответствующая паттерну – то
                    вы опять-таки нарушаете KISS, делая код сложнее, чем он мог бы быть.
                </p>
                <p>
                    <strong>На мой взгляд, принцип KISS может быть полезен лишь для начинающих проектировщиков</strong>,
                    которые не знают или не понимают основных принципов проектирования. KISS защищает от неверного
                    использования принципов проектирования и паттернов. Поскольку принципы и паттерны предназначены для
                    увеличения понятности кода, то их правильное использование не может привести к уменьшению понятности
                    кода. Однако если вы неверно понимаете принцип проектирования (например, истолковываете «не плодите
                    лишних сущностей» как «плодите как можно меньше сущностей»), или соблюдая один принцип нарушаете
                    десяток других, то KISS может стать для вас надёжной подушкой безопасности. В остальных случаях от
                    KISS-а мало толку, т.к. он слишком общий и абстрактный. Остальные же принципы более конкретны и
                    содержат более явные пути к достижению понятности и простоты кода.
                </p>
                <p>
                    Всвязи с тем, что представления разных людей о таком понятии как «простота» могут различаться,
                    приобрели широкое распространение
                    <strong> следующая заблуждения относительно KISS-a:</strong>
                    <div>
                        {' '}
                        Заблуждение 1. Если считать, что простой код – это такой код, который проще всего написать, то
                        можно истолковать, что принцип KISS призывает писать первое что взбредёт в голову, вообще не
                        задумываясь о проектировании.
                    </div>
                    <div>
                        Заблуждение 2. Если считать, что простой код – это такой код, для написания которого требуется
                        как можно меньше знаний, то можно истолковать, что принцип KISS призывает не использовать
                        паттерны проектирования.{' '}
                    </div>
                </p>
            </div>
        ),
    },
    yagni: {
        link: '/yagni',
        content: (
            <div>
                <h3>Принцип программирования YAGNI — «Вам это не понадобится»</h3>
                <p>
                    {' '}
                    <a href="https://web-creator.ru/articles/yagni">статья</a>
                </p>
                <p>
                    Если упрощенно, то следование данному принципу заключается в том, что возможности, которые не
                    описаны в требованиях к системе, просто не должны реализовываться. Это позволяет вести разработку,
                    руководствуясь экономическими критериями — Заказчик не должен оплачивать ненужные ему функции, а
                    разработчики не должны тратить своё оплачиваемое время на реализацию того, что не требуется.
                </p>
                <p>
                    Основная проблема, которую решает принцип YAGNI — это устранение тяги программистов к излишней
                    абстракции, к экспериментам «из интереса» и к реализации функционала, который сейчас не нужен, но,
                    по мнению разработчика, может либо вскоре понадобиться, либо просто будет полезен, хотя в реальности
                    такого очень часто не происходит.
                </p>
                <p>
                    «Бесплатных» функций в программных продуктах просто не бывает. Если рассматривать материальную
                    сторону, то любые ненужные, но фактически реализованные «фичи» оплачиваются либо Заказчиком (в
                    бюджет закладываются расходы на те функции, которые не нужны), либо Исполнителем из прибыли по
                    проекту. И тот, и другой варианты с точки зрения бизнеса неверны. Если же говорить о нематериальных
                    затратах, то любые «бонусные» возможности усложняют сопровождение, увеличивают вероятность ошибок и
                    усложняют взаимодействие с продуктом, — между объёмом кодовой базы и описанными характеристиками
                    есть прямая зависимость. Больше написанного кода — труднее сопровождать и выше вероятность появления
                    «багов», тут очень уместна поговорка: «лучший код — это ненаписанный код».
                </p>
                <p>
                    Принципы YAGNI и <Link to="/kiss">KISS</Link> очень похожи, если <Link to="/kiss">KISS</Link>{' '}
                    нацелен на упрощение и полезен в плане работы с теми требованиями, которые имеют место быть, то
                    YAGNI более категоричен и применяется для ограждения проектов по разработке ПО от «размывания» их
                    рамок.
                </p>
                <p>
                    <strong>
                        Подход к реализации проектов строго по ТЗ верен с нескольких ракурсов. Заказчик не должен
                        платить за то, что ему не надо, а продукт должен быть максимально сопровождаем и его качество не
                        должно страдать от интеграции ненужных функций.
                    </strong>
                </p>
            </div>
        ),
    },
    dry: {
        link: '/dry',
        content: (
            <div>
                <h3>Принцип программирования DRY — don’t repeat yourself / не повторяйте себя</h3>
                <p>
                    <a href="https://web-creator.ru/articles/dry">Статья</a>
                </p>
                <p>
                    Следование принципу программирования «DRY» позволяет добиться высокой сопровождаемости проекта,
                    простоты внесения изменений и качественного тестирования.
                </p>
                <p>
                    Если код не дублируется, то для изменения логики достаточно внесения исправлений всего в одном месте
                    и проще тестировать одну (пусть и более сложную) функцию, а не набор из десятков однотипных.
                    Следование принципу DRY всегда приводит к декомпозиции сложных алгоритмов на простые функции. А
                    декомпозиция сложных операций на более простые (и повторно используемые) значительно упрощает
                    понимание программного кода. Повторное использование функций, вынесенных из сложных алгоритмов,
                    позволяет сократить время разработки и тестирования новой функциональности.
                </p>
                <p>
                    Следование принципу DRY приводит к модульной архитектуре приложения и к чёткому разделению
                    ответственности за бизнес-логику между программными классами. А это — залог сопровождаемой
                    архитектуры. Хотя чаще не DRY приводит к модульности, а уже модульность, в свою очередь,
                    обеспечивает принципиальную возможность соблюдения этого принципа в больших проектах.
                </p>

                <p>
                    В рамках одного программного класса (или модуля) следовать DRY и не повторяться обычно достаточно
                    просто. Также не требует титанических усилий делать это в рамках небольших проектов, где все
                    разработчики «владеют» всем кодом системы. А вот в больших проектах ситуация с DRY несколько сложнее
                    — повторы чаще всего появляются из-за отсутствия у разработчиков целостной картины или
                    несогласованности действий в рамках команды. Следовать принципу «don’t repeat yourself» в рамках
                    больших проектов не так просто, как это может показаться на первый взгляд. От разработчиков
                    требуется тщательное планирование архитектуры, а от архитектора или тимлида требуется наличие
                    видения системы в целом и чёткая постановка задач разработчикам.
                </p>

                <p>
                    В пректировании DRY тоже имеет место — доступ к конкретному функционалу должен быть доступен в одном
                    месте, унифицирован и сгруппирован по какому-либо принципу, а не «разбросан» по системе в
                    произвольных вариациях. Этот подход пересекается с принципом единственной ответственности из пяти
                    принципов SOLID, сформулированных Робертом Мартином.
                </p>
            </div>
        ),
    },
    datastructures: {
        link: '/datastructures',
        content: (
            <div>
                <h3>Структуры данных</h3>
                <p>
                    Мякотка(даже скорее опорный конспект)
                    <a href="https://habr.com/ru/post/310794/">этого материала</a>
                </p>
                <p>Что нам дадут эти знания?</p>
                <div>
                    Штмл верстальщику/jquery developer-у из 2013, быть может и ничего. Но мускулистому разработчику
                    позволит:
                </div>
                <ul className="row list_style">
                    <li>Управлять сложностью своих программ, делая их доступней для понимания.</li>
                    <li>Создавать высокопроизводительные программы, эффективно работающие с памятью.</li>
                </ul>
                <h3>Что такое структуры данных?</h3>
                <p>
                    По сути, это способы хранить и организовывать данные, чтобы эффективней решать различные задачи.
                    Данные можно представить по-разному. В зависимости от того, что это за данные и что вы собираетесь с
                    ними делать, одно представление подойдёт лучше других.
                </p>

                <h3>Алгоритмы</h3>

                <div>Алгоритм — такое хитроумное название для последовательности совершаемых действий.</div>
                <div>
                    Структуры данных реализованы с помощью алгоритмов, алгоритмы — с помощью структур данных. Всё
                    состоит из структур данных и алгоритмов, вплоть до уровня, на котором бегают микроскопические
                    человечки с перфокартами и заставляют компьютер работать. Любая данная задача реализуется
                    бесконечным количеством способов. Как следствие, для решения распространённых задач изобрели
                    множество различных алгоритмов. Например, для сортировки неупорядоченного множества элементов
                    существует до смешного большое количество алгоритмов:{' '}
                </div>

                <div>
                    <ul className="list_style">
                        <li>
                            <a href="https://habr.com/ru/post/335920/">
                                Сортировка вставками, Сортировка выбором, Сортировка слиянием, Сортировка пузырьком,
                                Cортировка кучи, Быстрая сортировка, Сортировка Шелла, Сортировка Тима, Блочная
                                сортировка, Поразрядная сортировка...
                            </a>
                        </li>
                    </ul>
                </div>

                <div>
                    Некоторые из них значительно быстрее остальных. Другие занимают меньше памяти. Третьи легко
                    реализовать. Четвёртые построены на допущениях относительно наборов данных.
                </div>

                <div>
                    Каждая из сортировок подходит лучше других для определённой задачи. Поэтому вам надо будет сперва
                    решить, какие у вас потребности и критерии, чтобы понять, как сравнивать алгоритмы между собой.
                </div>

                <div>
                    Для сравнения производительности алгоритмов используется грубое измерение средней производительности
                    и производительности в худшем случае, для обозначения которых используется термин
                    <a href="https://webdevblog.ru/bolshoe-o-chto-eto-takoe-pochemu-eto-vazhno-i-pochemu-eto-ne-vazhno/">
                        {' '}
                        «О» большое.
                    </a>
                </div>

                <div>
                    «О» большое — обозначение способа приблизительной оценки производительности алгоритмов для
                    относительного сравнения.
                </div>

                <div>
                    О большое — заимствованное информатикой математические обозначение, определяющее, как алгоритмы
                    соотносятся с передаваемым им некоторым количеством N данных.
                </div>

                <div>О большое характеризует две основные величины:</div>

                <div>
                    Оценка времени выполнения — общее количество операций, которое алгоритм проведёт на данном множестве
                    данных.
                </div>

                <div>
                    Оценка объёма — общее количество памяти, требующееся алгоритму для обработки данного множества
                    данных.
                </div>

                <div>
                    Оценки делаются независимо друг от друга: одни алгоритмы могут производить меньше операций, чем
                    другие, занимая при этом больше памяти. Определив свои требования, вы сможете выбрать
                    соответствующий алгоритм.
                </div>

                <h3>Вот некоторые распространённые значения О большого:</h3>

                <p>взято с ориг истончика</p>
                <div>
                    <img src={require('./assets/obig.png')} />
                </div>
                <h3>Структуры данных непосредственно</h3>
                <p>разделим на две группы: использующие память напрмую и реализующие другие структуры данных</p>
                <h3>Напрямую</h3>
                <p>Списки</p>
                <p>Хэш - таблицы</p>
                <h3>Через другие</h3>
                <p>Стэки</p>
                <p>Графы</p>
                <p>Связанные списки</p>
                <p>Деревья</p>
                <p></p>
            </div>
        ),
    },
    adaptive: {
        link: '/adaptive',
        content: (
            <div>
                <h3>Виды медиа запросов</h3>
                <p>
                    <iframe
                        width="560"
                        height="315"
                        src="https://www.youtube.com/embed/XbnAKjjlgc4?start=1362"
                        frameborder="0"
                        allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
                        allowfullscreen></iframe>
                </p>
            </div>
        ),
    },
    jsnotes: {
        link: '/jsnotes',
        content: (
            <div>
                <h3>Заметки по js</h3>
                <ol className="row list_style">
                    <li>
                        <a href="https://pmashai.gitbooks.io/questions-for-calls/javascript.html">
                            Вопросы - ответы по js
                        </a>
                    </li>
                    <li>proto - ссылка на прототип объекта</li>
                    <li>
                        <img src={require('./assets/objpro.png')} />
                    </li>
                    <li>
                        Null (Null тип ) : typeof instance === "object". Специальный примитив, используемый не только
                        для данных но и в качестве указателя на финальную точку в Цепочке Прототипов;
                    </li>
                    <li>
                        Оператор instanceof проверяет, принадлежит ли объект к определённому классу. Другими словами,
                        object instanceof constructor проверяет, присутствует ли объект constructor.prototype в цепочке
                        прототипов object.
                    </li>
                    <li>
                        Как мы помним, примитивы не объекты. Но если мы попытаемся получить доступ к их свойствам, то
                        тогда будет создан временный объект-обёртка с использованием встроенных конструкторов String,
                        Number и Boolean, который предоставит методы и после этого исчезнет. Эти объекты создаются
                        невидимо для нас, и большая часть движков оптимизирует этот процесс, но спецификация описывает
                        это именно таким образом. Методы этих объектов также находятся в прототипах, доступных как
                        String.prototype, Number.prototype и Boolean.prototype.
                        <p>
                            Встроенные прототипы можно изменять. Например, если добавить метод к String.prototype, метод
                            становится доступен для всех строк
                        </p>
                    </li>
                    <li>
                        <a href="https://developer.mozilla.org/ru/docs/Web/API/Console/group">console.group</a>
                    </li>
                    <li>
                        <a href="https://learn.javascript.ru/object-toprimitive">Преобразование объектов в примитивы</a>
                    </li>
                    <li>
                        <a href="https://learn.javascript.ru/polyfills">Полифилы</a>
                    </li>
                    <li>
                        Упоротый пример. Контекст при привзяки мы берем в момент ВЫЗОВА А так как функия вне объекта
                        привязываем ее к window
                        <img src={require('./assets/uprt.png')} />
                    </li>
                    <li>
                        <a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D">
                            Ивент луп. IventLoop наглядно
                        </a>
                    </li>
                    <li>
                        PromiseAll вывод: сначала ретурны в МАССИВЕ.
                        <img src={require('./assets/promiseall.png')} />
                        Это свяано с порядком выполнения операций. Микротаски и макротаски.
                    </li>
                    <li>
                        Object.create может принимать второй аргумент. Объект. Однако значения ключей он принимает уже
                        не явно. А через дескрипторы.
                        <div>Пример маэстро</div>
                        <img src={require('./assets/descr.png')} />
                        <div></div>
                        <a href="https://learn.javascript.ru/descriptors-getters-setters">Статья про дескрипторы</a>
                    </li>
                    <li>
                        <a href="https://jsonplaceholder.typicode.com/">api</a> для тестирования работы с запросами
                    </li>
                    <li>
                        в классах родительсие методы переписываются, однако можно воспользоваться super.method() для
                        вызова оригинала
                    </li>
                    <li>Композиция для классов: Object.assign(classEx.prototype, ...needful opt)</li>
                    <li>
                        <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Reflect">
                            Рефлект{' '}
                        </a>
                        <a href="https://learn.javascript.ru/proxy">Proxy и Reflect</a>
                    </li>
                    <li>
                        <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith">
                            startwith проверяем начинается ли строка с..
                        </a>
                    </li>
                    <li>void 0 - альтернативная запись всемилюбимого indefined</li>
                    <li>
                        чтобы пройти по for of нужно реализоать symbol не работает:{' '}
                        <img src={require('./assets/notworkingforof.png')} />
                        работает:
                        <img src={require('./assets/symboliterator.png')} />
                    </li>
                    <li>
                        Шпора по XmlHttpRequest. Пусть будет. Promise реализация.
                        <img src={require('./assets/shopaxml.png')} />
                    </li>
                </ol>
            </div>
        ),
    },
    reactnotes: {
        link: '/reactnotes',
        content: (
            <div>
                <h3>Заметки по react</h3>
                <ol className="row list_style">
                    <li>
                        <a href="https://habr.com/ru/post/351168/">Статья про thunk и saga</a>
                    </li>
                    <li>
                        <a href="https://www.robinwieruch.de/react-render-props">render in props pattern</a>
                    </li>
                    <li>
                        <a href="https://habr.com/ru/company/ruvds/blog/428081/">RxJx React</a>
                    </li>
                </ol>
            </div>
        ),
    },
    others: {
        link: '/others',
        content: (
            <div>
                <h3>Прочие технологии</h3>
                <ol className="row list_style">
                    <li>
                        <a href="https://habr.com/ru/company/ruvds/blog/341880/">RxJx представление, </a>
                        <a href="https://medium.com/@toshabely/rxjs-%D1%81-%D0%BD%D1%83%D0%BB%D1%8F-%D0%BE%D0%B1%D0%B7%D0%BE%D1%80-%D0%BE%D0%B1%D0%BE%D0%B7%D1%80%D0%B5%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F-ca4d8e5fb386">
                            RxJx подробнее__но все равно нихрена не ясно,{' '}
                        </a>
                        <a href="https://habr.com/ru/post/438642/">почитаем это </a>
                    </li>
                </ol>
                <h3>Пример с реализацией rxjs</h3>
                <Gh />
            </div>
        ),
    },
    videobasejs: {
        link: '/videobasejs',
        content: (
            <div>
                <h3>Видеоуроки по js</h3>
                <ol className="row list_style">
                    <li>
                        <a href="https://www.youtube.com/watch?v=mbcP3Oc0PjU">Map. Set. WeakMap. WeakSet. Минин.</a>
                    </li>
                    <li>
                        <a href="https://www.youtube.com/watch?v=eKCD9djJQKc">
                            XHR XmlHttpRequest\Fetch\Браузерные интсрументы для работы с запросами. Минин.
                        </a>
                    </li>
                </ol>
            </div>
        ),
    },
    loadingpage: {
        link: './loadingpage',
        content: (
            <div>
                <h3>Что происходит,когда пользователь вбивает в браузерную строку адрес сайта.</h3>
                <div>
                    на основе <a href="https://habr.com/ru/company/htmlacademy/blog/254825/">этой статьи</a>
                    {' ,'}
                    что в свою очередь является транслейтом{' '}
                    <a href="https://github.com/alex/what-happens-when">вот этого </a>
                </div>
                <p></p>
                <div>
                    <strong>1.Нажата клавиша «g»(на примере google)</strong>
                </div>
                <div>
                    Браузер получает событие и запускается механизм автоподстановки. В зависимости от алгоритма браузера
                    и его режима (включена ли функция «инкогнито») в выпадающем окне под строкой URL пользователю будет
                    предложено определённое количество вариантов для автоподстановки.
                </div>
                <div>
                    Большинство алгоритмов автоподстановки ранжируют рекомендации в зависимости от истории поиска и
                    оставленных закладках. Некоторые браузеры (например, Rockmelt) даже предлагают профили друзей на
                    Facebook. Когда пользователь планирует напечатать в адресной строке «google.com», ничего из
                    вышеперечисленного не играет роли, но тем не менее выполнится большое количество кода, а
                    рекомендации будут обновляться с каждой новой напечатанной буквой. Возможно, браузер предложит
                    перейти на google.com, до того, как пользователь вобьёт адрес целиком.
                </div>
                <p></p>
                <div>
                    <strong>2.Сигнал о клавиши\тачсикрина поступает от устройства ввода к ос</strong>
                </div>
                <p></p>
                <div>
                    <strong>3.Парсинг URL</strong>
                </div>
                <div>Теперь у браузера есть следующая информация об URL:</div>
                <div>
                    <strong>Protocol «HTTP»</strong> Использовать «Hyper Text Transfer Protocol»
                </div>
                <div>
                    <strong>Resource «/»</strong> Показать главную (индексную) страницу
                </div>
                <div>
                    <strong>Это URL или поисковый запрос?</strong>
                    <div>
                        Когда пользователь не вводит протокол или доменное имя, то браузер «скармливает» то, что человек
                        напечатал, поисковой машине, установленной по умолчанию. Часто к URL добавляется специальный
                        текст, который позволяет поисковой машине понять, что информация передана из URL-строки
                        определённого браузера.
                    </div>
                </div>
                <div>
                    <strong>Список проверки HSTS</strong>
                </div>
                <ul className="list_style row">
                    <li>
                        Браузер проверяет список «предзагруженных HSTS (HTTP Strict Transport Security)». Это список
                        сайтов, которые требуют, чтобы к ним обращались только по HTTPS.
                    </li>
                    <li>
                        Если нужный сайт есть в этом списке, то браузер отправляет ему запрос через HTTPS вместо HTTP. В
                        противном случае, начальный запрос посылается по HTTP. (При этом сайт может использовать
                        политику HSTS, но не находиться в списке HSTS — в таком случае на первый запрос по HTTP будет
                        отправлен ответ о том, что необходимо отправлять запросы по HTTPS. Однако это может сделать
                        пользователя уязвимым к downgrade-атакам — чтобы этого избежать, в браузеры и включают список
                        HSTS).
                    </li>
                </ul>
                <div>
                    <strong>Конвертация не-ASCII Unicode символов в название хоста</strong>
                </div>
                <ul className="list_style row">
                    <li>Браузер проверяет имя хоста на наличие символов, отличных от a-z, A-Z, 0-9, -, или ..</li>
                    <li>
                        В случае доменного имени google.com никаких проблем не будет, но если бы домен содержал не-ASCII
                        символы, то браузер бы применил кодировку Punycode для этой части URL.
                    </li>
                </ul>
                <div>
                    <p></p>
                    <div>
                        <strong>4.Определение DNS</strong>
                    </div>
                    <ul className="list_style row">
                        <li>Браузер проверяет наличие домена в своём кэше.</li>
                        <li>
                            Если домена там нет, то браузер вызывает библиотечную функцию gethostbyname (отличается в
                            разных ОС) для поиска нужного адреса.
                        </li>
                        <li>
                            Прежде, чем искать домен по DNS gethostbyname пытается найти нужный адрес в файле hosts (его
                            расположение отличается в разных ОС).
                        </li>
                        <li>
                            Если домен нигде не закэширован и отсутствует в файле hosts, gethostbyname отправляет запрос
                            к сетевому DNS-серверу. Как правило, это локальный роутер или DNS-сервер
                            интернет-провайдера.
                        </li>
                        <li>Если DNS-сервер находится в той же подсети, то ARP-запрос отправляется этому серверу.</li>
                        <li>
                            Если DNS-сервер находится в другой подсети, то ARP-запрос отправляется на IP-адрес шлюза по
                            умолчанию (default gateway).
                        </li>
                    </ul>
                    <div>
                        <strong>ARP</strong>
                        <div>
                            ARP — протокол в компьютерных сетях, предназначенный для определения MAC-адреса по IP-адресу
                            другого компьютера.
                        </div>
                        <div>
                            <strong>Назначение протокола:</strong> Преобразование сетевых адресов в канальные
                        </div>
                        <div>
                            <strong>Уровень (по модели OSI):</strong>Канальный
                        </div>
                    </div>
                </div>
                <p></p>
                <div>
                    <strong>Процесс отправки ARP-запроса</strong>
                </div>
                <div>
                    Для того, чтобы отправить широковещательный ARP-запрос необходимо отыскать целевой IP-адрес, а также
                    знать MAC-адрес интерфейса, который будет использоваться для отправки ARP-запроса.
                </div>
                <div>
                    Кэш ARP проверяется для каждого целевого IP-адреса — если адрес есть в кэше, то библиотечная функция
                    возвращает результат: Target IP = MAC.
                </div>
                <p></p>
                <div>Если же записи в кэше нет:</div>
                <ul className="list_style row">
                    <li>
                        Проверяется таблица маршрутизации — это делается для того, чтобы узнать, есть ли искомый
                        IP-адрес в какой-либо из подсетей локальной таблицы. Если он там, то запрос посылается с помощью
                        интерфейса, связанного с этой подсетью. Если адрес в таблице не обнаружен, то используется
                        интерфейс подсети шлюза по умолчанию.
                    </li>
                    <li>Определяется MAC-адрес выбранного сетевого интерфейса.</li>{' '}
                    <li>Отправляется ARP-запрос (второй уровень стека):</li>
                </ul>
                <p></p>
                <div>
                    Теперь у сетевой библиотеки есть IP-адрес либо DNS-сервера либо шлюза по умолчанию, который можно
                    использовать для разрешения доменного имени:
                </div>
                <ul className="list_style row">
                    <li>
                        Порт 53 открывается для отправки UDP-запроса к DNS-серверу (если размер ответа слишком велик,
                        будет использован TCP).
                    </li>
                    <li>
                        Если локальный или на стороне провайдера DNS-сервер «не знает» нужный адрес, то запрашивается
                        рекурсивный поиск, который проходит по списку вышестоящих DNS-серверов, пока не будет найдена
                        SOA-запись, а затем возвращается результат.
                    </li>
                </ul>
                <p></p>
                <div>
                    <strong>5. Открытие сокета</strong>
                    <div>
                        Когда браузер получает IP-адрес конечного сервера, то он берёт эту информацию и данные об
                        используемом порте из URL (80 порт для HTTP, 443 для HTTPS) и осуществляет вызов функции socket
                        системной библиотеки и запрашивает поток TCP сокета — AF_INET и SOCK_STREAM.
                    </div>
                    <ul className="list_style row">
                        <li>
                            Этот запрос сначала проходит через транспортный уровень, где собирается TCP-сегмент. В
                            заголовок добавляется порт назначения, исходный порт выбирается из динамического пула ядра
                            (ip_local_port_range в Linux).
                        </li>
                        <li>
                            Получившийся сегмент отправляется на сетевой уровень, на котором добавляется дополнительный
                            IP-заголовок. Также включаются IP-адрес сервера назначения и адрес текущей машины — после
                            этого пакет сформирован.
                        </li>
                        <li>
                            Пакет передаётся на канальный уровень. Добавляется заголовок кадра, включающий MAC-адрес
                            сетевой карты (NIC) компьютера, а также MAC-адрес шлюза (локального роутера). Как и на
                            предыдущих этапах, если ядру ничего не известно о MAC-адресе шлюза, то для его нахождения
                            отправляется широковещательный ARP-запрос.
                        </li>
                    </ul>
                    <div>На этой точке пакет готов к передаче через:</div>
                    <ul className="list_style row">
                        <li>Ethernet</li>
                        <li>WiFi</li>
                        <li>По сотовой связи</li>
                    </ul>
                    <div>
                        В случае интернет-соединения большинства частных пользователей или небольших компаний пакет
                        будет отправлен с компьютера, через локальную сеть, а затем через модем (MOdulator/DEModulator),
                        который транслирует цифровые единицы и нули в аналоговый сигнал, подходящий для передачи по
                        телефонной линии, кабелю или беспроводным телефонным соединениям. На другой стороне соединения
                        расположен другой модем, который конвертирует аналоговый сигнал в цифровые данные и передаёт их
                        следующему сетевому узлу, где происходит дальнейший анализ данных об отправителе и получателе.
                    </div>
                    <p></p>
                    <div>
                        В конечном итоге пакет доберётся до маршрутизатора, управляющего локальной подсетью. Затем он
                        продолжит путешествовать от одного роутера к другому, пока не доберётся до сервера назначения.
                        Каждый маршрутизатор на пути будет извлекать адрес назначения из IP-заголовка и отправлять пакет
                        на следующий хоп. Значение поля TTL (time to live) в IP-заголовке будет каждый раз уменьшаться
                        после прохождения каждого роутера. Если значение поля TTL достигнет нуля, пакет будет отброшен
                        (это произойдёт также если у маршрутизатора не будет места в текущей очереди — например, из-за
                        перегрузки сети).
                    </div>
                    <p></p>
                    <div>Во время TCP-соединения происходит множество подобных запросов и ответов.</div>
                    <p></p>
                </div>
                <div>
                    <strong>5.Жизненный цикл TCP-соединения</strong>
                    <p></p>
                    <div>
                        <strong>
                            a. Клиент выбирает номер начальной последовательности (ISN) и отправляет пакет серверу с
                            установленным битом SYN для открытия соединения.
                        </strong>
                    </div>
                    <div>
                        <strong>
                            b. Сервер получает пакет с битом SYN и, если готов к установлению соединения, то:
                        </strong>
                        <ul className="list_style row">
                            <li>Выбирает собственный номер начальной последовательности;</li>
                            <li>Устанавливает SYN-бит, чтобы сообщить о выборе начальной последовательности</li>
                            <li>
                                Копирует ISN клиента +1 в поле ACK и добавляет ACK-флаг для обозначения подтверждения
                                получения первого пакета.
                            </li>
                        </ul>
                        <div>
                            <strong>c. Клиент подтверждает соединение путём отправки пакета:</strong>
                        </div>
                        <ul className="list_style row">
                            <li>Увеличивает номер своей начальной последовательности;</li>
                            <li>Увеличивает номер подтверждения получения;</li>
                            <li>Устанавливает поле ACK.</li>
                        </ul>
                        <div>
                            <strong>d. Данные передаются следующим образом:</strong>
                        </div>
                        <ul className="list_style row">
                            <li>
                                Когда одна сторона отправляет N байтов, то увеличивает значение поля SEQ на это число.
                            </li>
                            <li>
                                Когда вторая сторона подтверждает получение этого пакета (или цепочки пакетов), она
                                отправляет пакет ACK, в котором значение поля ACK равняется последней полученной
                                последовательности.
                            </li>
                        </ul>
                        <div>
                            <strong>e. Закрытие соединения:</strong>
                        </div>
                        <ul className="list_style row">
                            <li>Сторона, которая хочет закрыть соединение, отправляет пакет FIN;</li>
                            <li>Другая сторона подтверждает FIN (с помощью ACK) и отправляет собственный FIN-пакет;</li>
                            <li>
                                Инициатор прекращения соединения подтверждает получение FIN отправкой собственного ACK.
                            </li>
                        </ul>
                    </div>
                </div>
                <p></p>
                <div>
                    <strong>TLS handshake</strong>
                    <div>
                        <strong>TLS</strong>, как и его предшественник SSL, — криптографические протоколы,
                        обеспечивающие защищённую передачу данных между узлами в сети Интернет. TLS и SSL используют
                        асимметричное шифрование для аутентификации, симметричное шифрование для конфиденциальности и
                        коды аутентичности сообщений для сохранения целостности сообщений.
                    </div>
                    <p></p>
                    <ul className="list_style row">
                        <li>
                            Клиентский компьютер отправляет сообщение ClientHello серверу со своей версией протокола
                            TLS, списком поддерживаемых алгоритмов шифрования и методов компрессии данных.
                        </li>
                        <li>
                            Сервер отвечает клиенту сообщением ServerHello, содержащим версию TLS, выбранный метод
                            шифрования, выбранные методы компрессии и публичный сертификат сервиса, подписанный центром
                            сертификации. Сертификат содержит публичный ключ, который будет использоваться клиентом для
                            шифрования оставшейся части процедуры «рукопожатия» (handshake), пока не будет согласован
                            симметричный ключ.
                        </li>
                        <li>
                            Клиент подтверждает сертификат сервера с помощью своего списка центров сертификации. Если
                            сертификат подписан центром из списка, то серверу можно доверять, и клиент генерирует строку
                            псевдослучайных байтов и шифрует её с помощью публичного ключа сервера. Эти случайные байты
                            могут быть использованы для определения симметричного ключа.
                        </li>
                        <li>
                            Сервер расшифровывает случайные байты с помощью своего секретного ключа и использует эти
                            байты для генерации своей копии симметричного мастер-ключа.
                        </li>
                        <li>
                            Клиент отправляет серверу сообщение Finished, шифруя хеш передачи с помощью симметричного
                            ключа.
                        </li>
                        <li>
                            Сервер генерирует собственный хеш, а затем расшифровывает полученный от клиента хеш, чтобы
                            проверить, совпадёт ли он с собственным. Если совпадение обнаружено, сервер отправляет
                            клиенту собственный ответ Finished, также зашифрованный симметричным ключом.
                        </li>
                        <li>
                            После этого TLS-сессия передаёт данные приложения (HTTP), зашифрованные с помощью
                            подтверждённого симметричного ключа.
                        </li>
                    </ul>
                </div>
                <p></p>
                <div>
                    <strong>7. Протокол HTTP</strong>
                </div>
                <div>
                    Если используемый браузер был создан Google, то вместо отправки HTTP-запроса для получения страницы,
                    он отправит запрос, чтобы попытаться «договориться» с сервером об «апгрейде» протокола с HTTP до{' '}
                    <a href="https://ru.wikipedia.org/wiki/SPDY">SPDY</a> («спиди»).
                </div>
                <div>
                    Если клиент использует HTTP-протокол и не поддерживает SPDY, то отправляет серверу запрос следующей
                    формы:
                </div>
                <img src={require('./assets/http.png')} />
                <div>
                    где [другие заголовки] — это серия пар «ключ: значение», разбитых переносом строки. (Здесь
                    предполагается, что в использованном браузере нет никаких ошибок, нарушающих спецификацию HTTP.
                    Также предполагается, что браузер использует HTTP/1.1, в противном случае он может не включать
                    заголовок Host в запрос и версия, отданная в ответ на GET-запрос может быть HTTP/1.0 или HTTP/0.9).
                </div>
                <div>
                    HTTP/1.1 определяет опцию закрытия соединения («close») для отправителя — с её помощью происходит
                    уведомление о закрытии соединения после завершения ответа. К примеру:
                </div>
                <img src={require('./assets/close.png')} />
                <div>
                    Приложения HTTP/1.1, которые не поддерживают постоянные соединения, обязаны включать опцию «close» в
                    каждое сообщение.
                </div>
                <p></p>
                <div>
                    После отправки запроса и заголовков, браузер отправляет серверу единичную пустую строку,
                    сигнализируя о том, что содержимое сообщения закончилось.
                </div>
                <p></p>
                <div>
                    Сервер отвечает специальным кодом, который обозначает статус запроса и включает ответ следующей
                    формы:
                </div>
                <img src={require('./assets/200ok.png')} />
                <p></p>
                <div>
                    После этого посылается пустая строка, а затем оставшийся контент HTML-страницы www.google.com.
                    Сервер может затем закрыть соединение, или, если того требуют отправленные клиентом заголовки,
                    сохранять соединение открытым для его использования следующими запросами.
                </div>
                <p></p>
                <div>
                    Если HTTP-заголовки отправленные веб-браузером включают информацию, которой серверу достаточно для
                    определения версии файла, закэшированного в браузере и этот файл не менялся со времени последнего
                    запроса, то ответ может принять следующую форму:
                </div>
                <img src={require('./assets/304.png')} />
                <div>
                    и, соответственно, клиенту не посылается никакого контента, вместо этого браузер «достаёт» HTML из
                    кэша.
                </div>
                <p></p>
                <div>
                    После разбора HTML, браузер (и сервер) повторяет процесс загрузки для каждого ресурса (изображения,
                    стили, скрипты, favicon.ico и так далее), на который ссылается HTML-страница, но при этом изменяется
                    адрес каждого запроса c GET / HTTP/1.1 на GET /$(относительный URL ресурса www.google.com) HTTP/1.1.
                </div>
                <div>
                    Если HTML ссылается на ресурс, размещённый на домене, отличном от google.com, то браузер
                    возвращается к шагам, включающим разрешение доменного имени, а затем заново проходит процесс до
                    текущего состояния, но уже для другого домена. Заголовок Host в запросе вместо google.com будет
                    установлен на нужное доменное имя.
                </div>
                <p></p>
                <div>Обработка HTTP-запросов на сервере</div>
                <div>
                    HTTPD (HTTP Daemon) является одним из инструментов обработки запросов/ответов на стороне сервера.
                    Наиболее популярные HTTPD-серверы это Apache или Nginx для Linux и IIS для Windows
                </div>
                <p></p>
                <div>— HTTPD (HTTP Daemon) получает запрос.</div>
                <p></p>
                <div> — Сервер разбирает запрос по следующим параметрам:</div>
                <ul className="list_style row">
                    <li>
                        Метод HTTP-запроса (GET, POST, HEAD, PUT или DELETE). В случае URL-адреса, который пользователь
                        напечатал в строке браузера, мы имеем дело с GET-запросом.
                    </li>
                    <li>Домен. В нашем случае — google.com.</li>
                    <li>
                        Запрашиваемые пути/страницы, в нашем случае — / (нет запрошенных путей, / — это путь по
                        умолчанию).
                    </li>
                </ul>
                <p></p>
                <div>— Сервер проверяет существование виртуального хоста, который соответствует google.com.</div>
                <p></p>
                <div>— Сервер проверяет, что google.com может принимать GET-запросы.</div>
                <p></p>
                <div>
                    Сервер проверяет, имеет ли клиент право использовать этот метод (на основе IP-адреса, аутентификации
                    и прочее).
                </div>
                <p></p>
                <div>
                    — Если на сервере установлен модуль перезаписи (mod_rewrite для Apache или URL Rewrite для IIS), то
                    он сопоставляет запрос с одним из сконфигурированных правил. Если находится совпадающее правило, то
                    сервер использует его, чтобы переписать запрос.
                </div>
                <p></p>
                <div>
                    — Сервер находит контент, который соответствует запросу, в нашем случае он изучит индексный файл.
                </div>
                <p></p>
                <div>
                    — Далее сервер разбирает («парсит») файл с помощью обработчика. Если Google работает на PHP, то
                    сервер использует PHP для интерпретации индексного файла и направляет результат клиенту.
                </div>
                <p></p>
                <div>
                    <strong>8. За кулисами браузера</strong>
                    <div>
                        Задача браузера заключается в том, чтобы показывать пользователю выбранные им веб-ресурсы,
                        запрашивая их с сервера и отображая в окне просмотра. Как правило такими ресурсами являются
                        HTML-документы, но это может быть и PDF, изображения или контент другого типа. Расположение
                        ресурсов определяется с помощью URL.
                    </div>
                    <div>
                        Способ, который браузер использует для интерпретации и отображения HTML-файлов описан в
                        спецификациях HTML и CSS. Эти документы разработаны и поддерживаются консорциумом W3C (World
                        Wide Wib Consortium), которая занимается стандартизацией веба.
                    </div>
                    <p></p>
                    <div>
                        <strong>Высокоуровневая структура браузера</strong>
                    </div>
                    <div>Браузер включает следующие компоненты:</div>
                    <ul className="list_style row">
                        <li>
                            Пользовательский интерфейс: В него входит адресная строка, кнопки продвижения вперёд/назад,
                            меню закладок и так далее. Сюда относятся все элементы, кроме окна, в котором собственно
                            отображается веб-страница.
                        </li>
                        <li>
                            «Движок» браузера: Распределяет действия между движком рендеринга и интерфейсом
                            пользователя.
                        </li>
                        <li>
                            «Движок» рендеринга: Отвечает за отображение запрашиваемого контента. К примеру, если
                            запрашивается HTML, то «движок» разбирает код HTML и CSS, а затем отображает полученный
                            контент на экране.
                        </li>
                        <li>
                            Сетевая часть: с помощью сетевых функций браузер обрабатывает вызовы, вроде HTTP-запросов, с
                            применением различных реализаций для разных платформ.
                        </li>
                        <li>
                            Бэкенд интерфейса (UI): Используется для отрисовки базовых виджетов, вроде комбо-боксов и
                            окон.
                        </li>
                        <li>Интерпретатор JavaScript: Используется для парсинга и выполнения JavaScript-кода.</li>
                        <li>
                            Хранилище данных: Браузеру может понадобиться локально хранить некоторые данные (например,
                            cookie). Кроме того, браузеры поддерживают различные механизмы хранения, такие как
                            localStorage, IndexedDB, WebSQL и FileSystem.
                        </li>
                    </ul>
                </div>
                <div>
                    <p></p>
                    <div>
                        Далее материал <a href="https://habr.com/ru/post/320430/">отсюда</a>
                    </div>
                    <div>
                        Браузеру предстоит пройти много шагов, прежде чем HTML-ответ от сервера будет преобразован в
                        пиксели на экране. Последовательность этих шагов, необходимая для первого отображения страницы,
                        называется <strong>«Критический путь рендеринга» (ориг. Critical Rendering Path).</strong>
                    </div>
                    <div>
                        Знание о CRP (Critical Rendering Path) невероятно полезно для понимания того, как улучшить
                        производительность сайта.
                    </div>
                    <p></p>
                    <div>Существует 6 этапов CRP:</div>
                    <ul>
                        <li>построение DOM-дерева,</li>
                        <li>построение CSSOM-дерева,</li>
                        <li>запуск JavaScript,</li>
                        <li>создание Render-дерева,</li>
                        <li>генерация раскладки,</li>
                        <li>отрисовка.</li>
                    </ul>
                    <div>
                        {' '}
                        <img src={require('./assets/crp.png')} />
                    </div>
                    <p></p>
                    <div>
                        <strong>Построение DOM-дерева</strong>
                        <div>
                            DOM (объектная модель документа) дерево это объект, представляющий полностью разобранную
                            HTML-страницу. Начиная с корневого элемента html, узлы создаются для каждого элемента/текста
                            на странице. Элементы, вложенные в другие элементы, представлены в виде дочерних узлов, и
                            каждый узел содержит полный набор атрибутов для этого элемента. Например, элемент a будет
                            иметь атрибут href, связанный с узлом.
                        </div>
                        <div>
                            Хорошая новость, касательно HTML, заключается в том, что он может быть исполнен по частям.
                            Документ не должен быть загружен полностью для того, чтобы контент начал появляться на
                            странице. Однако, другие ресурсы, такие как CSS и JavaScript, могут блокировать отрисовку
                            страницы.
                        </div>
                        <p></p>
                        <div>
                            <strong>Построение CSSOM-дерева</strong>
                        </div>
                        <div>
                            CSSOM (объектная модель CSS) — это объект, представляющий стили, связанные с DOM. Он
                            выглядит так же как DOM, но с соответствующими стилями для каждого узла. Не имеет значения
                            были ли стили объявлены явно или наследуются.
                        </div>
                        <div>
                            CSS считается «блокирующим обработку ресурсом». Это значит, что Render-дерево (см. ниже) не
                            может быть построено без полного первоначального разбора CSS.
                        </div>
                        <div>
                            В отличии от HTML, CSS не может быть использован по частям в силу своей каскадной природы.
                            Стили, описанные в документе ниже, могут переопределять и изменять стили, определённые
                            ранее. Так что если мы начнём использовать CSS-стили до того, как будет разобрана таблица
                            стилей, мы можем столкнуться с ситуацией, когда стили будут применяться неверно. Это
                            означает, что для перехода к следующему шагу, необходимо полностью разобрать CSS.
                        </div>
                        <div>
                            CSS-файлы блокируют рендер только если они применяются. link rel="stylesheet" может
                            принимать медиа-атрибут, в котором мы можем указать любое медиавыражение, к которому будут
                            относиться вложенные внутрь стили. Если, например, мы имеем таблицу стилей с медиа-атрибутом
                            orientation:landscape, а мы просматриваем страницу в портретном режиме, то этот ресурс не
                            будет считаться блокирующим обработку.
                        </div>
                        <div>
                            CSS также может являться «блокирующим скрипты», потому что JavaScript-файлы должны дождаться
                            построения CSSOM, прежде чем начать исполняться.
                        </div>
                        <p></p>
                        <div>Запуск JavaScript</div>
                        <div>
                            JavaScript является блокирующим ресурсом для парсера. Это означает, что JavaScript блокирует
                            разбор самого HTML-документа
                        </div>
                        <div>
                            Когда парсер доходит до тега script (не важно внутренний он или внешний), он
                            останавливается, забирает файл (если он внешний) и запускает его. Вот почему, если мы имеем
                            JavaScript-файл, который ссылается на элементы документа, мы обязательно должны поместить
                            его после их появления.
                        </div>
                        <div>
                            JavaScript можно загружать асинхронно, указав атрибут async, для того, чтобы избежать
                            блокировки парсера.
                        </div>
                    </div>
                    <p></p>
                    <div>
                        <strong>Создание Render-дерева</strong>
                        <div>
                            Render-дерево — это совокупность DOM и CSSOM. Это дерево, которое даёт представление о том,
                            что в конечном итоге будет отображено на странице. Это означает, что оно захватывает только
                            видимый контент и не включает, например, элементы, которые были скрыты с помощью CSS-правила
                            display: none.
                        </div>
                        <p></p>
                        <div>
                            <strong>Генерация раскладки</strong>
                            <div>
                                Раскладка — это то, что определяет размер видимой области документа (viewport), которая
                                обеспечивает контекст для стилей CSS, зависимых от него, например, проценты или единицы
                                вьюпорта.
                            </div>
                            <div>
                                Размер вьюпорта определяется метатэгом, находящемся в head документа или, если тэг не
                                представлен, будет использовано стандартное значение вьюпорта шириною в 980 пикселей.
                            </div>
                            <div>
                                Например, наиболее частым значением для этого метатэга является размер, соответствующий
                                с шириной устройства.
                            </div>
                            <div>
                                Например, наиболее частым значением для этого метатэга является размер, соответствующий
                                с шириной устройства.
                            </div>
                            <div>
                                Если пользователь посещает веб-страницу с устройства, ширина которого, например 1000
                                пикселей, то размеры будут опираться на это значение. Половина видимой области будет
                                равна 500 пикселей, 10 процентов — 100 пикселей, и так далее.
                            </div>
                        </div>
                    </div>
                    <p></p>
                    <div>
                        <strong>Отрисовка</strong>
                        <div>
                            Наконец, на шаге отрисовки, видимый контент страницы может быть преобразован в пиксели,
                            чтобы появиться на экране.
                        </div>
                        <div>
                            Время, которое займет этот этап, зависит как от величины DOM, так и от того, какие стили
                            применяются. Некоторые стили требуют больше усилий, чтобы быть применёнными, чем другие.
                            Например, сложное градиентное фоновое изображение потребует больше времени, чем простой
                            сплошной цвет на фоне.
                        </div>
                    </div>
                    <p></p>
                    <div>
                        <strong>Собираем всё вместе</strong>
                    </div>
                    <div>
                        Чтобы увидеть как происходит критический путь рендеринга, мы можем воспользоваться инструментами
                        разработчика. В Chrome это можно сделать во вкладке «Timeline» (в Canary, а так же скоро в
                        стабильных версия Chrome, вкладка переименована в «Performance»).
                    </div>
                    <div>
                        <img src={require('./assets/load.png')} />
                    </div>
                    <div>
                        <ol className="list_style row">
                            <li>Send Request — GET-запрос, отправленный для index.html;</li>
                            <li>
                                Parse HTML and Send Request — начать разбор HTML и построение DOM. Отправить GET запрос
                                для style.css и main.js;
                            </li>
                            <li>Parse Stylesheet — CSSOM, созданный для style.css;</li>
                            <li>Evaluate Script — вычислить (выполнить) main.js;</li>
                            <li>Layout — генерация раскладки, основанной на значении метатега viewport;</li>
                            <li>Paint — отрисовка пикселей в документе.</li>
                        </ol>
                        <div>
                            Опираясь на эту информацию, мы можем принимать решения, направленные на оптимизацию
                            критического пути рендеринга. Я расскажу о некоторых таких техниках в дальнейших
                            публикациях.
                        </div>
                    </div>
                    <strong>12. Рендеринг GPU</strong>
                    <ul className="list_style row">
                        <li>
                            Во время процесса рендеринга уровни графических вычислений могут использовать процессор
                            компьютера или графический процессор (GPU).
                        </li>
                        <li>
                            Во втором случае уровни графического программного обеспечения делят задачу на множество
                            частей, что позволяет использовать параллелизм GPU для вычисления плавающей точки, которое
                            требуется для процесса рендеринга.
                        </li>
                    </ul>
                </div>
                <p></p>
                <div></div>
                <div>
                    <strong>13. Вызванное пользователем и пост-рендеринговое исполнение</strong>
                    <div>
                        После завершения рендеринга, браузер исполняет JavaScript-код в результате срабатывания некоего
                        часового механизма (так работают дудлы на странице Google) или в результате действий
                        пользователя (ввод поискового запроса в строку и получение рекомендаций в ответ). Также могут
                        срабатывать плагины вроде Flash или Java (но не в рассматриваемом примере с домашней страницей
                        Google). Скрипты могут потребовать обработки дополнительных сетевых запросов, изменять страницу
                        или её шаблон, что приведёт к следующему этапу рендеринга и отрисовки.
                    </div>
                </div>
                <div>
                    <a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path?hl=ru">
                        тут подробнее + анализ и оптимизация процесса визуализации
                    </a>
                </div>
            </div>
        ),
    },
    requests: {
        link: '/request',
        content: (
            <div>
                <h3>Работа с запросами</h3>
                <p></p>
                <div>
                    Запросы на различные API в js осуществляются при помощи следующих методов.
                    <ul className="list_style row">
                        <li>базовый, нативный метод - httpXmlRequest. Лежит под копотом прочих</li>
                        <li>В эпоху расцвета jquery использовался jquery-ajax </li>
                        <li>Сейчас основное api это Fetch о нем и пойдет речь далее</li>
                        <li>Есть различные библиотеки. Напимере axios. Но в основе все равно лежит fetch</li>
                    </ul>
                </div>
                <p></p>
                <div>Работа с api - это http запрос, плэтому для начала стоит разобрать виды этих запросов</div>
                <p></p>
                <div>
                    HTTP определяет множество методов запроса, которые указывают, какое желаемое действие выполнится для
                    данного ресурса. Несмотря на то, что их названия могут быть существительными, эти методы запроса
                    иногда называются HTTP глаголами. Каждый реализует свою семантику, но каждая группа команд разделяет
                    общие свойства: так, методы могут быть{' '}
                    <a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/safe">
                        безопасными
                    </a>
                    ,{' '}
                    <a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/Idempotent">
                        идемпотентными
                    </a>{' '}
                    или{' '}
                    <a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/cacheable">
                        кэшируемыми.
                    </a>
                </div>
                <p></p>
                <div>Краткое описание методов</div>
                <ul className="list_style row">
                    <li>
                        GET Метод GET запрашивает представление ресурса. Запросы с использованием этого метода могут
                        только извлекать данные.
                    </li>
                    <li>HEAD запрашивает ресурс так же, как и метод GET, но без тела ответа.</li>
                    <li>
                        POST используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение
                        состояния или какие-то побочные эффекты на сервере.
                    </li>
                    <li>PUT заменяет все текущие представления ресурса данными запроса.</li>
                    <li>DELETE удаляет указанный ресурс.</li>
                    <li>CONNECT устанавливает "туннель" к серверу, определённому по ресурсу.</li>
                    <li>OPTIONS используется для описания параметров соединения с ресурсом.</li>
                    <li>TRACE выполняет вызов возвращаемого тестового сообщения с ресурса.</li>
                    <li>PATCH используется для частичного изменения ресурса.</li>
                </ul>
                <p></p>
                <div>
                    <a href="https://developer.mozilla.org/ru/docs/Web/HTTP/CORS">CORS</a>
                </div>
                <div>
                    <a href="https://developer.mozilla.org/ru/docs/Web/HTTP/%D0%97%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%B8">
                        Заголовки
                    </a>
                </div>
                <p></p>
                <div>
                    <strong>Fetch</strong>
                    <div>
                        <strong>Особенности</strong>
                        <div>
                            <ul className="list_style row">
                                <li>
                                    Promise возвращаемый вызовом fetch() не перейдет в состояние "отклонено" из-за
                                    ответа HTTP, который считается ошибкой, даже если ответ HTTP 404 или 500. Вместо
                                    этого, он будет выполнен нормально (с значением false в статусе ok ) и будет
                                    отклонён только при сбое сети или если что-то помешало запросу выполниться.
                                </li>
                                <li>
                                    По умолчанию, fetch не будет отправлять или получать cookie файлы с сервера, в
                                    результате чего запросы будут осуществляться без проверки подлинности, что приведёт
                                    к неаутентифицированным запросам, если сайт полагается на проверку пользовательской
                                    сессии (для отправки cookie файлов в аргументе init options должно быть задано
                                    значение свойства credentials отличное от значения по умолчанию omit(c 2017-
                                    same-origin)).
                                </li>
                            </ul>
                        </div>
                    </div>
                    <div>let promise = fetch(url, [options])</div>
                    <ul className="list_style row">
                        <li>url – URL для отправки запроса.</li>
                        <li>options – дополнительные параметры: метод, заголовки и так далее.</li>
                    </ul>
                    <div>
                        <img src={require('./assets/fetch.png')} />
                    </div>
                    <div>
                        <strong>Методы обработки ответа</strong>
                        <ul className="list_style row">
                            <li>response.text() – читает ответ и возвращает как обычный текст,</li>
                            <li>response.json() – декодирует ответ в формате JSON,</li>
                            <li>
                                response.formData() – возвращает ответ как объект{' '}
                                <a href="https://learn.javascript.ru/formdata">FormData</a>
                            </li>
                            <li>
                                response.blob() – возвращает объект как{' '}
                                <a href="https://learn.javascript.ru/blob">Blob</a> (бинарные данные с типом),
                            </li>
                            <li>
                                response.arrayBuffer() – возвращает ответ как{' '}
                                <a href="https://learn.javascript.ru/arraybuffer-binary-arrays">ArrayBuffer</a>{' '}
                                (низкоуровневое представление бинарных данных),
                            </li>
                            <li>
                                помимо этого, response.body – это объект{' '}
                                <a href="https://streams.spec.whatwg.org/#rs-class">ReadableStream</a>, с помощью
                                которого можно считывать тело запроса по частям.{' '}
                            </li>
                        </ul>
                        <div>
                            <div>
                                <strong>Заголовки</strong>
                            </div>
                            <div>
                                Интерфейс Headers позволяет вам создать ваш собственный объект заголовков через
                                конструктор Headers(). Объект заголовков - простая мультикарта имён-значений:
                            </div>
                            <div>Можно получить заголовки ответа.</div>
                            <div>
                                <img src={require('./assets/headers.png')} />
                            </div>
                        </div>
                        <div>
                            <strong>Заголовки запроса</strong>
                            <div>
                                Для установки заголовка запроса в fetch мы можем использовать опцию headers. Она
                                содержит объект с исходящими заголовками, например:
                            </div>
                            <div>
                                <img src={require('./assets/headersreq.png')} />
                                <img src={require('./assets/head.png')} />
                            </div>
                        </div>
                        <p></p>
                        <div>
                            <strong>POST-запросы</strong>
                            <div>
                                Для отправки POST-запроса или запроса с другим методом, нам необходимо использовать
                                fetch параметры:
                            </div>
                            <ul className="list_style row">
                                <li>method – HTTP метод, например POST</li>
                                <li>
                                    body – тело запроса, одно из списка:
                                    <ul className="list_style row">
                                        <li>строка (например, в формате JSON),</li>
                                        <li>объект FormData для отправки данных как form/multipart,</li>
                                        <li>Blob/BufferSource для отправки бинарных данных,</li>
                                        <li>
                                            <a href="https://learn.javascript.ru/url">URLSearchParams</a> для отправки
                                            данных в кодировке x-www-form-urlencoded, используется редко.
                                        </li>
                                        <li>
                                            <img src={require('./assets/post.png')} />
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        ),
    },
    jsinheritance: {
        link: '/jsinheritance',
        content: (
            <div>
                <h3>Наследование в js</h3>
                <p></p>
                <div>
                    В джс,как известно, наследование имеет прототипный характер. Значит что каждый объект наследуетс от
                    другого. Который и зовется прототипом. Последование наследование объектов друг от друга называется
                    цепочкой прототипов.
                </div>
                <div>
                    В JavaScript объекты имеют специальное скрытое <strong>свойство [[Prototype]]</strong>(так оно
                    названо в спецификации), которое либо равно null, либо ссылается на другой объект. Этот объект
                    называется «прототип»
                </div>
                <div>
                    Свойство [[Prototype]] является внутренним и скрытым, но есть много способов задать его. Одним из
                    них является использование <strong>__proto__</strong>, например так:
                </div>
                <p></p>
                <div>
                    <strong>
                        Свойство __proto__ — исторически обусловленный геттер/сеттер для [[Prototype]] Обратите
                        внимание, что __proto__ — не то же самое, что [[Prototype]]. Это геттер/сеттер для него.
                    </strong>{' '}
                    Он существует по историческим причинам,
                    <strong>
                        {' '}
                        в современном языке его заменяют функции Object.getPrototypeOf/Object.setPrototypeOf
                    </strong>
                    , которые также получают/устанавливают прототип.
                </div>
                <p></p>
                <div>
                    <strong>F.prototype</strong>
                </div>
                <div>
                    <strong>Новые объекты</strong> могут быть созданы при помощи функции-конструктора New
                </div>
                <div>
                    Если в F.prototype содержится объект, оператор new устанавливает его в качестве [[Prototype]] для
                    нового объекта.
                </div>
                <div>
                    <strong>
                        .prototype это НЕ ССЫЛКА на прототип объекта, и не сам прототип. Это просто свойство и если оно
                        содержит объект то объект будет использован в качестве прототипа в new
                    </strong>
                </div>
                <div>
                    <strong>
                        У каждой функции есть по умолчанию есть свойство prototype. Котоое содержит поле constructor.
                    </strong>{' '}
                    Новый объект, созданый через New соответвенно получает constructor
                </div>
                <div>
                    Такая вот петрушка
                    <img src={require('./assets/petrushka.png')} />
                    <img src={require('./assets/result1.png')} />
                </div>
            </div>
        ),
    },
    debAndThrott: {
        link: './debandthrott',
        content: (
            <div>
                <h3>Throttling и Debouncing</h3>
                <p></p>
                <div>Если вкратце:</div>
                <div>
                    <strong>Throttling</strong> означает что функция вызывается не чаще определенного интервала n.
                    Тоесть мы вызвали функцию f. И если не прошло n мс. То f не будет вызвана повторно.
                </div>
                <div>
                    <strong>Debouncing</strong> Если в истечении n mc ,f будет вызвана повторно. Вызов не сработает. А n
                    обнулится.
                </div>
                <div>
                    Подробнее читаем{' '}
                    <a href="https://medium.com/nuances-of-programming/%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-throttling-%D0%B8-debouncing-4f0a839769ef">
                        статью
                    </a>
                </div>
            </div>
        ),
    },
    comments: {
        link: '/comments',
        content: (
            <div>
                <h3>Рекомендации по коментированию кода</h3>
                <div>
                    <a href="https://learn.javascript.ru/comments">Статья</a>
                </div>
                <div>
                    <a href="https://tproger.ru/articles/comments-in-code/">Статья 2</a>
                </div>
            </div>
        ),
    },
    ustrict: {
        link: './ustrict',
        content: (
            <div>
                <h3>Use strict</h3>
                <div>
                    <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode">Статья</a>
                </div>
                <div>
                    <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode">
                        Статья 2
                    </a>
                </div>
                <p></p>
                <div>
                    <string>Положения</string>
                </div>
                <div>
                    <ol className="list_style row">
                        <li>
                            {' '}
                            Cтрогий режим заменяет исключениями некоторые ошибки, которые интерпретатор JavaScript ранее
                            молча пропускал
                        </li>
                        <li>
                            {' '}
                            Cтрогий режим исправляет ошибки, которые мешали движкам JavaScript выполнять оптимизацию --
                            в некоторых случаях код в строгом режиме может быть оптимизирован для более быстрого
                            выполнения, чем код в обычном режиме
                        </li>
                        <li>
                            {' '}
                            Cтрогий режим запрещает использовать некоторые элементы синтаксиса, которые, вероятно, в
                            следующих версиях ECMAScript получат особый смысл.
                        </li>
                        <li> Модуль по умолчанию в строгом режиме.</li>
                    </ol>
                    <p></p>
                    <div>
                        <strong>Суть</strong>
                        <ol className="list_style row">
                            <li>
                                Если не в строгом режиме объявить перемнную без let const или var - код выполнется. В
                                строгом - выбросит ошибку
                            </li>
                            <li>
                                Присваивание нового свойства нерасширяемому объекту(допустим дискриптор writable =
                                false), в строгом режиме выбросит исключение.
                            </li>
                            <li>
                                В строгом режиме попытки удалить неудаляемые свойства будут вызывать исключения (в то
                                время как прежде такая попытка просто не имела бы эффекта). Прим. delete
                                Object.prototype
                            </li>
                            <li>
                                Cтрогий режим требует, чтобы имена аргументов в объявлении функций встречались только
                                один раз. В обычном коде последний повторённый аргумент скрывает предыдущие аргументы с
                                таким же именем.
                            </li>
                            <li>Cтрогий режим запрещает синтаксис восьмеричной системы счисления. Прим: 015</li>
                            <li>
                                Cтрогий режим в ECMAScript 2015 запрещает установку свойств primitive значениям. Без
                                строгого режима, установка свойств просто игнорируется (no-op), со строгим режимом,
                                однако, выдает TypeError. Прим. false.true
                            </li>
                        </ol>
                        <p></p>
                        <div>
                            <strong>
                                Строгий режим упрощает сопоставление имени переменной с местом ее определения в коде.
                                Многие оптимизации времени компиляции полагаются на возможность считать, что переменная
                                X хранится в этом конкретном месте исходного кода. Иногда, при компиляции JavaScript
                                простое сопоставление имени переменной с местом ее определения в коде не возможно, без
                                выполнения того самого кода. Строгий же режим исключает большинство таких случаев,
                                благодаря чему оптимизации компилятора работают эффективнее.
                            </strong>
                            <ul className="list_style row">
                                <li>
                                    Cтрогий режим запрещает использование with. Проблема с with в том, что во время
                                    выполнения любое имя внутри блока может ссылаться как на свойство обрабатываемого
                                    объекта, так и на переменную в окружающем (или даже в глобальном) контексте --
                                    невозможно знать об этом заранее.
                                </li>
                                <li>
                                    Eval в строгом режиме не добавляет новых переменных в окружающий контекст. В обычном
                                    режиме, при вызове eval("var x;") переменная x добавится в область видимости
                                    окружающей функции либо в глобальный контекст.{' '}
                                </li>
                                <li>
                                    Cтрогий режим запрещает удаление простых имён. delete name в строгом режиме является
                                    синтаксической ошибкой. Прим. let x = 0; delete x;
                                </li>
                            </ul>
                        </div>
                        <p></p>
                        <div>
                            <strong>
                                В строгом режиме снижается количество странностей в поведении arguments и eval, оба из
                                которых примешивают определённое количество магии в обычный код. Так eval добавляет или
                                удаляет переменные и меняет их значения, а переменная arguments может удивить своими
                                проиндексированными свойствами, которые являются ссылками (синонимами) для
                                проименованных аргументов функции. Строгий режим делает большой шаг в прояснении этих
                                двух ключевых слов, но полное их обуздание произойдет лишь в следующей редакции
                                ECMAScript.
                            </strong>
                        </div>
                        <div>
                            <ul className="list_style row">
                                <li>
                                    Ключевые слова eval и arguments не могут быть переопределены или изменены. Все
                                    подобные попытки это сделать являются синтаксическими ошибками
                                </li>
                                <li>
                                    В строгом режиме поля объекта arguments не связаны с проименованными аргументами
                                    функции, а являются их продублированными копиями значений. В обычном коде внутри
                                    функции, первым аргументом которой является arg, изменение значения переменной arg
                                    также меняет значение и у поля arguments[0], и наоборот (кроме случаев, когда
                                    аргумент в функцию не передан, или arguments[0] удалён). В строгом режиме arguments
                                    хранит копии значений аргументов переданных при вызове функции. arguments[i] не
                                    отслеживает изменений соответствующего именованного аргумента, и именованный
                                    аргумент не отслеживает значение соответствующего arguments[i].
                                </li>
                                <li>
                                    {' '}
                                    Cвойство arguments.callee больше не поддерживается. В обычном коде свойство
                                    arguments.callee ссылается на саму функцию для вызова которой и был создан объект
                                    arguments. Малоприменимое свойство, так как функция заранее известна, и к ней можно
                                    обратиться и по ее имени непосредственно. Более того, arguments.callee значительно
                                    затрудняет такую оптимизацию, как инлайнинг, потому как должна быть сохранена
                                    возможность обратиться к незаинлайненой функции на случай, если присутствует
                                    обращение к arguments.callee. В строгом режиме arguments.callee превращается в
                                    неудаляемое свойство, которое выбрасывает предостерегающее исключение при любой
                                    попытке обращения к нему
                                </li>
                            </ul>
                        </div>
                        <div>
                            <strong>
                                Строгий режим упрощает написание "безопасного" JavaScript кода. Сейчас некоторые
                                веб-сайты предоставляют пользователям возможность писать JavaScript, который будет
                                выполняться на сайте от имени других пользователей. В браузерах, JavaScript может иметь
                                доступ к приватной информации пользователя, поэтому, в целях ограничения доступа к
                                запретной функциональности, такой JavaScript перед выполнением должен быть частично
                                преобразован. Гибкость JavaScript делает это практически невозможным без многочисленных
                                проверок во время исполнения. Функционал, исполняемый языком иногда столь массивен, что
                                выполнение любых дополнительных проверок во время исполнения скрипта приведет к
                                значительной потере производительности. Однако, некоторые особенности строгого режима,
                                плюс обязательное требование того, чтобы JavaScript, загруженный пользователем, имел
                                строгий режим и вызывался определенным способом, существенно снижают потребность в таких
                                проверках.
                            </strong>
                        </div>
                        <div>
                            <ol className="list_style row">
                                <li>
                                    Значение, передаваемое в функцию как this, в строгом режиме не приводится к объекту
                                    (не "упаковывается"). В обычной функции this всегда представляет собой объект: либо
                                    это непосредственно объект, в случае вызова с this, представляющим объект-значение;
                                    либо значение, упакованное в объект, в случае вызова с this типа Boolean, string,
                                    или number; либо глобальный объект, если тип this это undefined или null.
                                </li>
                            </ol>
                        </div>
                    </div>
                </div>
            </div>
        ),
    },
    datastructurejs: {
        link: '/datastructurejs',
        content: (
            <div>
                <h3>Типы данных JavaScript и структуры данных</h3>
                <div>
                    <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Data_structures">Статья</a>
                    <a href="https://pmashai.gitbooks.io/questions-for-calls/javascript.html">
                        Тут есть про типы данных
                    </a>
                </div>
            </div>
        ),
    },
    rest: {
        link: '/rest',
        content: (
            <div>
                <h3>REST</h3>
                <p></p>
                <div>
                    На этот раз начнем не с определения. Ибо сложно придумать более унылое занятие чем чтение про rest.
                    Вроде все понятно и по русски, но зачем и главное нувыпоянли.
                </div>
                <p></p>
                <div>
                    Итак. Допустим у нас есть приложение. Все ок. Работает. Ибо мы уже читали про{' '}
                    <Link to="/oop">оопе</Link> и другие умные вещи про разработку и наладили наше приложение как надо.
                    Теперь перед нами встает задача взаимодействия с другими сервисами.
                </div>
                <div>Например: </div>
                <div>
                    <ul className="list_style row">
                        <li>
                            Предоставить возможность предоставить число подписчиков, продаж, адресов и прочего на
                            каком-то сайте, приложении
                        </li>
                        <li>
                            Дать возможность пользователю менять свои настроки, допустим через приложение. Или прочие
                            возаимодействия с андроид, ядлочными приложениями
                        </li>
                        <li>
                            Автоматические действия на строннем сайте, после успешной оплаты клиента на веб-сервисе{' '}
                        </li>
                    </ul>
                </div>
                <p></p>
                <div>
                    <strong>Проблематика</strong>
                </div>
                <div>
                    Клиентаская часть может быть написана на разных ЯП, использоваться разная архитектура хранения
                    данных, операционная ситема, сисетемное и аппаратное взаимодействие. В общем нам нужно обеспечить
                    взаимодействие между абсолютно разными системами
                </div>
                <div>Единственное, что их объеденяет - они могут работать по сети интернет через протокол HTTP</div>
                <p></p>
                <div>Тут то нам на помощь и приходит REST!</div>
                <div>
                    <strong>Rest это просто набор правил</strong>, следуя которым наше приложение станет расширяемым для
                    взаимодествия с раличными системами
                </div>
                <p></p>
                <div>Теперь вернемся к определениям</div>
                <div>
                    <strong>
                        REST (от англ. Representational State Transfer — «передача состояния представления») —
                        архитектурный стиль взаимодействия компонентов распределённого приложения в сети. REST
                        представляет собой согласованный набор ограничений, учитываемых при проектировании
                        распределённой гипермедиа-системы. В определённых случаях (интернет-магазины, поисковые системы,
                        прочие системы, основанные на данных) это приводит к повышению производительности и упрощению
                        архитектуры.{' '}
                    </strong>
                    В широком смысле компоненты в REST взаимодействуют наподобие взаимодействия клиентов и серверов во
                    Всемирной паутине.
                </div>
                <p></p>
                <div>
                    В сети Интернет вызов удалённой процедуры может представлять собой обычный HTTP-запрос (обычно «GET»
                    или «POST»; такой запрос называют «REST-запрос»), а необходимые данные передаются в качестве
                    параметров запроса.
                </div>
                <p></p>
                <div>
                    Для веб-служб, построенных с учётом REST (то есть не нарушающих накладываемых им ограничений),
                    применяют термин «RESTful».
                </div>
                <p></p>
                <div>
                    <strong>Свойства Архитектуры REST</strong>
                </div>
                <div>
                    <ul className="list_style row">
                        <li>
                            Производительность — взаимодействие компонентов системы может являться доминирующим фактором
                            производительности и эффективности сети с точки зрения пользователя;
                        </li>
                        <li>
                            Масштабируемость для обеспечения большого числа компонентов и взаимодействий компонентов.
                        </li>
                        <li>Простота унифицированного интерфейса;</li>
                        <li>
                            Открытость компонентов к возможным изменениям для удовлетворения изменяющихся потребностей
                            (даже при работающем приложении);
                        </li>
                        <li>Прозрачность связей между компонентами системы для сервисных служб;</li>
                        <li>Переносимость компонентов системы путем перемещения программного кода вместе с данными;</li>
                        <li>
                            Надёжность, выражающаяся в устойчивости к отказам на уровне системы при наличии отказов
                            отдельных компонентов, соединений или данных.
                        </li>
                    </ul>
                </div>
                <p></p>
                <div>
                    <strong>Требования к архитектуре REST</strong>
                    <p></p>
                    <div>
                        Существует шесть обязательных ограничений для построения распределённых REST-приложений по
                        Филдингу. Выполнение этих ограничительных требований обязательно для REST-систем. Накладываемые
                        ограничения определяют работу сервера в том, как он может обрабатывать и отвечать на запросы
                        клиентов. Действуя в рамках этих ограничений, система приобретает такие желательные свойства как
                        производительность, масштабируемость, простота, способность к изменениям, переносимость,
                        отслеживаемость и надёжность. Если сервис-приложение нарушает любое из этих ограничительных
                        условий, данную систему нельзя считать REST-системой. Обязательными условиями-ограничениями
                        являются:
                    </div>
                    <ol className="list_style row">
                        <li>
                            <strong>Модель клиент-сервер</strong>. Первым ограничением, применимым к гибридной модели,
                            является приведение архитектуры к модели клиент-сервер. Разграничение потребностей является
                            принципом, лежащим в основе данного накладываемого ограничения. Отделение потребности
                            интерфейса клиента от потребностей сервера, хранящего данные, повышает переносимость кода
                            клиентского интерфейса на другие платформы, а упрощение серверной части улучшает
                            масштабируемость. Наибольшее же влияние на всемирную паутину, пожалуй, имеет само
                            разграничение, которое позволяет отдельным частям развиваться независимо друг от друга,
                            поддерживая потребности в развитии интернета со стороны различных организаций.
                        </li>
                        <li>
                            <strong>Отсутствие состояния</strong>. Протокол взаимодействия между клиентом и сервером
                            требует соблюдения следующего условия: в период между запросами клиента никакая информация о
                            состоянии клиента на сервере не хранится (Stateless protocol или «протокол без сохранения
                            состояния»). Все запросы от клиента должны быть составлены так, чтобы сервер получил всю
                            необходимую информацию для выполнения запроса. Состояние сессии при этом сохраняется на
                            стороне клиента. Информация о состоянии сессии может быть передана сервером какому-либо
                            другому сервису (например, в службу базы данных) для поддержания устойчивого состояния,
                            например, на период установления аутентификации. Клиент инициирует отправку запросов, когда
                            он готов (возникает необходимость) перейти в новое состояние. Во время обработки клиентских
                            запросов считается, что клиент находится в переходном состоянии. Каждое отдельное состояние
                            приложения представлено связями, которые могут быть задействованы при следующем обращении
                            клиента.
                        </li>
                        <li>
                            <strong> Кэширование</strong>. Как и во Всемирной паутине, клиенты, а также промежуточные
                            узлы, могут выполнять кэширование ответов сервера. Ответы сервера, в свою очередь, должны
                            иметь явное или неявное обозначение как кэшируемые или некэшируемые с целью предотвращения
                            получения клиентами устаревших или неверных данных в ответ на последующие запросы.
                            Правильное использование кэширования способно полностью или частично устранить некоторые
                            клиент-серверные взаимодействия, ещё больше повышая производительность и расширяемость
                            системы.
                        </li>
                        <li>
                            <strong>Единообразие интерфейса</strong>
                            Наличие унифицированного интерфейса является фундаментальным требованием дизайна
                            REST-сервисов. Унифицированные интерфейсы позволяют каждому из сервисов развиваться
                            независимо. К унифицированным интерфейсам предъявляются следующие четыре ограничительных
                            условия:
                            <ul className="list_style row">
                                <li>
                                    <strong>Идентификация ресурсов</strong>
                                    Все ресурсы идентифицируются в запросах, например, с использованием URI в
                                    интернет-системах. Ресурсы концептуально отделены от представлений, которые
                                    возвращаются клиентам. Например, сервер может отсылать данные из базы данных в виде
                                    HTML, XML или JSON, ни один из которых не является типом хранения внутри сервера.
                                </li>
                                <li>
                                    <strong>Манипуляция ресурсами через представление</strong>
                                    Если клиент хранит представление ресурса, включая метаданные — он обладает
                                    достаточной информацией для модификации или удаления ресурса.
                                </li>
                                <li>
                                    <strong>«Самоописываемые» сообщения</strong>
                                    Каждое сообщение содержит достаточно информации, чтобы понять, каким образом его
                                    обрабатывать. К примеру, обработчик сообщения (parser), необходимый для извлечения
                                    данных, может быть указан в списке MIME-типов.
                                </li>
                                <li>
                                    <strong>Гипермедиа как средство изменения состояния приложения (HATEOAS)</strong>
                                    Клиенты изменяют состояние системы только через действия, которые динамически
                                    определены в гипермедиа на сервере (к примеру, гиперссылки в гипертексте). Исключая
                                    простые точки входа в приложение, клиент не может предположить, что доступна
                                    какая-то операция над каким-то ресурсом, если не получил информацию об этом в
                                    предыдущих запросах к серверу. Не существует универсального формата для
                                    предоставления ссылок между ресурсами, RFC 5988 и JSON Hypermedia API Language
                                    являются двумя популярными форматами предоставления ссылок в REST HYPERMEDIA
                                    сервисах.
                                </li>
                            </ul>
                        </li>
                        <li>
                            <strong>Слои</strong>. Клиент обычно не способен точно определить, взаимодействует он
                            напрямую с сервером или же с промежуточным узлом, в связи с иерархической структурой сетей
                            (подразумевая, что такая структура образует слои). Применение промежуточных серверов
                            способно повысить масштабируемость за счёт балансировки нагрузки и распределённого
                            кэширования. Промежуточные узлы также могут подчиняться политике безопасности с целью
                            обеспечения конфиденциальности информации.
                        </li>
                        <li>
                            <strong>Код по требованию (необязательное ограничение)</strong>. REST может позволить
                            расширить функциональность клиента за счёт загрузки кода с сервера в виде апплетов или
                            сценариев. Филдинг утверждает, что дополнительное ограничение позволяет проектировать
                            архитектуру, поддерживающую желаемую функциональность в общем случае, но, возможно, за
                            исключением некоторых контекстов.
                        </li>
                    </ol>
                </div>
                <p></p>
                <div>
                    <strong>Преимущества</strong>
                    <div>
                        Филдинг указывал, что приложения, не соответствующие приведённым условиям, не могут называться
                        REST-приложениями. Если же все условия соблюдены, то, по его мнению, приложение получит
                        следующие преимущества:
                    </div>
                    <ul className="list_style row">
                        <li>
                            Надёжность (за счёт отсутствия необходимости сохранять информацию о состоянии клиента,
                            которая может быть утеряна);
                        </li>
                        <li>Производительность (за счёт использования кэша);</li>
                        <li>Масштабируемость;</li>
                        <li>
                            Прозрачность системы взаимодействия (особенно необходимая для приложений обслуживания сети);
                        </li>
                        <li>Простота интерфейсов;</li>
                        <li>Портативность компонентов;</li>
                        <li>Лёгкость внесения изменений;</li>
                        <li>
                            Способность эволюционировать, приспосабливаясь к новым требованиям (на примере Всемирной
                            паутины).
                        </li>
                    </ul>
                </div>
                <p></p>
                <div>
                    <strong>Видео</strong>
                </div>
                <div>
                    <ul className="list_style row">
                        <li>
                            <a href="https://www.youtube.com/watch?v=C2TMZeRdLKw">Видео по REST и SOAP </a>
                        </li>
                        <li>
                            <a href="https://www.youtube.com/watch?v=lzQIhjElV_g&list=WL&index=19&t=0s">
                                Ну и кудаж без Минина + хороший пример на VUE
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        ),
    },
};

export default Articles;
